'''[::Edebug]''' is a source level debugger for EmacsLisp.  It 
instruments code. This means that Emacs adds special
instructions to the code when it is evaluated.  The main entry point
is `M-x edebug-defun' (also on `C-u C-M-x').  Use it instead of `C-x
C-e' or `C-M-x' to evaluate a `defun' and instrument it for debugging.

`edebug-defun' must be able
to read your code.  It expects all function
definitions to start in column 0.  If they do not, hitting `C-u C-M-x' 
will show you the wrong function name in the [[echo area]].

== Example ==

Paste the following functions into the `*scratch*' buffer (starting at column 0).  Hit `C-M-x' with the [[cursor]]
inside each of the function definitions.

    (defun foo ()
      (interactive)
      (bar))
     
    (defun bar ()
      (let ((a 5)
	    (b 7))
	(message "%d" (+ a b))))

Use `M-x foo'.  This prints ##12## in the echo area.

Now instrument `bar' by moving the cursor into its code and hitting `C-u
C-M-x'.  The echo area shows ##Edebug: bar##.

Use `M-x foo' again.  Emacs steps through the code of
`bar', showing you the result of evaluating each sexp in the echo area.  Hit `SPC'
to step ahead or `e' to evaluate another expression.
The arrow shows you which sexp will be evaluated next:

    (defun bar ()
    =>(let ((a 5)
	    (b 7))
	(message "%d" (+ a b))))

To quit the debugger, type `q'. 

Edebug can enter any defun whose source ban be found with FindFunc by hitting `i' which steps into the next function to be evaluated.  This instruments the function and will be debugged every time it is run.

You can disable edebug on a function by evaluating the function again using `C-M-x' without a PrefixArgument.

You can see the code coverage of the defun at point with `C-x X =' or `M-x edebug-display-freq-count'.

== Inserting a direct call to edbug ==

    (defmacro stop-here (fn)
       "Call edebug here. FN is assumed to be a symbol of the function you are in."
       `(if (consp (get ,fn 'edebug))
           (edebug)))
    
    (defun clear-edebug (fn-sym)
      "Remove 'edebug property from FN-SYM, a function symbol.
      (put fn-sym 'edebug nil)
    )

    ;; An example of use:
    (defun fact (n)
      (cond ((eq n 0) )
        ((eq n 1) 1)
        ((>  n 1) (progn (stop-here 'fact) (* n (fact (1- n)))))
        (t nil))
     )

If you eval the above and then edebug-defun while the point is on fact, you'll first stop at fact but then when you enter `g' for `go' it will next stop after the <tt>(* n</tt>...<tt> )</tt> which is what I want.

And note you could also put a condition around `stop-here` for example:

        ((>  n 1) (progn (if (= n 3) (stop-here 'fact)) (* n (fact (1- n)))))

What's hoaky about the above is all the verbiage in the <tt>(progn</tt> ... <tt>)</tt> and that you have to enter the function argument <tt>'fact</tt> in `stop-here'. There may be a way to reduce this in the `stop-here' macro.


See also
DebuggerMode,
EmacsLispTracing.

----
CategoryDebug
