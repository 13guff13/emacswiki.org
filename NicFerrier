Iâ€™m [::nicferrier], a hacker trying to do interesting things. I use Emacs every day all the time.

I am currently the CTO at [http://woome.com woome.com]. 

I've used Emacs for about 20 years, every day, all the time for the last 15 years. The last couple of years I've started to look at ELisp as a practical language (since it had closures basically) in which I might one day do all my work.


== Recent Emacs related blog posts ==

[http://nic.ferrier.me.uk/blog/2011_09/elisp_testing ERT has been included in trunk so now EmacsLISP TDD is possible]

[http://nic.ferrier.me.uk/blog/2010_10/elnode about Elnode, the EmacsLISP asycnc HTTP server]


== asynchronous HTTP servers for Emacs (EmacsLISP node.js)  == 
[[Elnode]] is an asynchronous TCP server handling HTTP.

As of now elnode is just about functional. I am starting to write things with it including a port of my wiki based blog.

It's pretty good. I hope people pick it up because it's an interesting way to leverage Emacs.

== Emacs under Mercurial ==

* I host a mercurial copy of the emacs bzr repo at bitbucket: https://bitbucket.org/nic/emacs
** and [https://bitbucket.org/nic/emacs-update/changeset/14a32e93c535 here is the update script I use]

Mercurial is really good at making upstream/downstream hacks. Is
anyone interested in a clone of Emacs with, say auto-install,
pre-installed.


== Email under Emacs ==

I've never liked gnus. But I do like Emacs as a mail platform so I've always maintained my own mail code.

Back in the last 90s I wrote an [[imapua|Emacs IMAP user agent based on the GNUs IMAP library]].
It worked pretty well but IMAP didn't really scale for me once my
inbox got really really big (20k messages plus). The IMAP protocol is
actually quite difficult to deal with asynchrnously so I got more and
more stuck with email.

Eventually I decided to bite the bullet and write my own low level
email handling. [https://github.com/nicferrier/md the md command] is
the result. [https://github.com/nicferrier/md md] is a command for
reading mail stored in a Maildir. It is ''just'' a unix command
tool. It is completely stateless (apart from the Maildir).

My primary usage of the [https://github.com/nicferrier/md md] tool is
via an
[https://github.com/nicferrier/md/blob/master/useragents/emacs/mdmua.el Emacs user agent]. 
This is currently very simple but already most powerful enough for
everyday use.

The user agent doesn't need to do complex tasks because I can script
those with regular unix pipelines. Here's an example BASH script which
uses [https://github.com/nicferrier/md md] to move all the messages
with a particular month pattern to a different folder:

{{{
#!/bin/bash
# A script to pull all the email for a particular month pattern out of
# the INBOX and into a separate dir.
DATEPAT=$1
echo $DATEPAT | grep -E '[0-9]{4}-[0-9]{2}' > /dev/null
if [ $? -ne 0 ]
then
    echo "incorrect date pattern - eg: mdmonthmove 2011-09"
    exit 1
fi
# Date pattern must be ok
DATEDIR=$(echo $DATEPAT | sed -rne 's/([0-9]{4})-([0-9]{2})/\1\2/p')
md ls \
    | awk -v DATEPAT=$DATEPAT '$2 ~ DATEPAT {print $1}' \
    | sed -rne 's/^INBOX#(.*)/\1/p' \
    | while read message
do 
    echo $message >> $MAILDIR/$DATEPAT--move.log
    mv $MAILDIR/cur/$message* $MAILDIR/.$DATEDIR/cur/
done
}}}

I am continuing to develop this despite the fact that no one but me
seems interested. It's actually quite cheap to maintain and improve.


== Templating in emacs ==

If we're going to have a webserver we need a better way of making
HTML. I've been kicking around ideas for small template languages in
Javascript... seems like it should be easy to port them to lisp.

[new]
I had a few cracks at this before coming up with [[Sweat|'''sweat''']] which is a very lispy version of another template system of mine (for javascript) called '''tache'''. 

[[Sweat|Sweat]] is designed to solve the problem of how you make a tidy and straight forward template in a functional language. Here's a complex example:

{{{
(sweat-let ((title "nic's demo")
            (items (stream-from-list
                    (lambda (item)
                      `((name . ,(car item))
                        (value . ,(cdr item))))
                    '(("username" . "nicferrier")
                      ("firstname" . "nic")))))
           "<html><head><title>::title::</title><head><body><ul>"
           (sweat-* items "<li>::name:: - ::value::</li>")
           "</ul></body></html>")
}}}

Go see the wiki page for slightly more info.

I mainly think it was fun playing with macros for HTML representation. There may be mileage in this but I am now of the view that LISP spitting back JSON is probably better.
 
== Emacs in a screen terminal: colors ==
I do some remote pair programming inside screen. I would like to use emacs. Standard colors are too difficult for me to read (my eyes are going!).

vim has the very nice: 

{{{
set background=dark
}}}

which turns up the brightness on dark font faces. According to #emacs we have no equivalent.

So I wrote one:

{{{
(defvar dark-background nil)

(defun toggle-dark-background ()
  (interactive)
  (let ((difficult-colors
         '("red" "blue" "medium blue")))
    (mapc
     (lambda (face)
       (and (member (face-attribute face :foreground)  difficult-colors)
            (set-face-bold-p face (not dark-background))))
     (face-list)))
  (setq dark-background (not dark-background)))
}}}  

This toggles bold on the dark ones, which I think is all the vim thing is doing.

== Small Init Files ==

For a long time I've used a complex init file with loads of stuff in
it. This is great, it means emacs starts up with all my goodies. But
it also means when I go to another emacs I'm lost. It's also
non-trivial to move my stuff to another emacs.

I am trying to pair down my emacs use to the standard dist delivered
behaviour and then add obvious extras on top. This is a process I
started long ago but is still underway.

I've just discovered [[AutoInstall|auto install]] which helps greatly
in defining a smaller .emacs. Why? Because now I can keep the packages
I use in the EmacsWiki and just use auto-install to load them:

{{{
;; Nic's init file

(add-to-list 'load-path (expand-file-name "~/.emacs.d/"))
(require 'auto-install)

;; config stuff...
...
;; End
}}}

I have patched auto-install slightly. It's a very simple patch that
causes everything that has been auto-installed to be loaded on
startup:

{{{
;; Automatic loading

(defcustom auto-install-inhibit-startup-loading nil
  "Controls whether auto-installed packaged are loaded at startup.

If set to 't this inhibts the automatic loading of auto-load
files at startup. 

Otherwise all files in the 'auto-install-directory' are loaded
when auto-install is required."
  :type 'string
  :group 'auto-install)

(defun auto-install-on-startup ()
  "Require everything in the auto-install directory."
  (when (not auto-install-inhibit-startup-loading)
    (mapc (lambda (direntry)
            (let ((path (concat
                         (file-name-as-directory auto-install-directory)
                         direntry)))
              (when (and (file-readable-p path) 
                         (not (file-directory-p path))
                         (equal "el" (file-name-extension path)))
                (load-file path))))
          (directory-files auto-install-directory))))

;; Attempt to load all the auto-install files
(auto-install-on-startup)
}}}

Hopefully [[rubikitch]] will be able to add that to
auto-install. Ideally, it would do the kind of things that [[ELPA]]
does.


== List of various other ELisp bits and pieces ==

I've done a few things with emacs which I'm trying to push into this wiki:

* [[pastebin]] -- a simple interface to the [http://www.pastebin.com pastebin.com] webservice
* [[rcircPresence]] -- for syncing rcirc with some other presence thing (eg: skype)
* [[imapua]] -- a purely IMAP based email client for Emacs
* [[trac_editor]] -- a very simple interface to trac.py
* [[WikiDoc]] -- a program to make wiki documentation from Elisp functions
* [[tzhelp]] -- a small set of tools for dealing with timezones


---- 
CategoryHomepage
