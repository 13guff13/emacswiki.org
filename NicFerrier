I’m [::nicferrier], a hacker trying to do interesting things. I use Emacs every day all the time.

I am currently the CTO at [http://woome.com woome.com]. Anyone who may
be interested in a job hacking at woome.com can come talk to
[mailto:nic@woome.com me]. We use python and gnu-linux and all good
things.

I've done a few things with emacs which I'm trying to push into this wiki:

* [[pastebin]] -- a simple interface to the [http://www.pastebin.com pastebin.com] webservice
* [[rcircPresence]] -- for syncing rcirc with some other presence thing (eg: skype)
* [[imapua]] -- a purely IMAP based email client for Emacs
* [[trac_editor]] -- a very simple interface to trac.py
* [[WikiDoc]] -- a program to make wiki documentation from Elisp functions
* [[tzhelp]] -- a small set of tools for dealing with timezones

== Emacs under Mercurial ==

* I host a mercurial copy of the emacs bzr repo at bitbucket: https://bitbucket.org/nic/emacs
** and [https://bitbucket.org/nic/emacs-update/changeset/14a32e93c535 here is the update script I use]

Mercurial is really good at making upstream/downstream hacks. Is
anyone interested in a clone of Emacs with, say auto-install,
pre-installed.

== Things I am interested in doing ==

* getting the smallest most adaptable init file I can
* getting emacs to talk to dbus for things like IM alerts
** I use bitlbee/rcirc for all my im... but it's not good notification wise
* improving emacs as a mail client
* xml edting
* python editing
* exploting emacs async nature

== node js for emacs == 
[[Elnode]] is an asynchronous TCP server handling HTTP.

As of now elnode is just about functional. I am starting to write things with it including a port of my wiki based blog.

It's pretty good. I hope people pick it up because it's an interesting way to leverage Emacs.

== Templating in emacs ==

If we're going to have a webserver we need a better way of making
HTML. I've been kicking around ideas for small template languages in
Javascript... seems like it should be easy to port them to lisp.

Here's a first crack:

{{{
(defun list-to-alist (&rest lst)
  "Convert a list to an alist
(list-to-alist 'name "value" 'name "value")
=> ((name "value")
    (name "value"))
"
  (let ((l lst)
        res)
    (while (cdr l)
      (let ((a (car l))
            (b (cadr l)))
        (setq res (cons (cons a b) res))
        (setq l (cddr l))))
    res))

(defun tc (template &rest args)
  "Do template replacement.

{{value}} indicates a name in the args (a list of pairs) which is replaced with the value."
  (let ((ctx (apply 'list-to-alist args))
        (tmpl template))
    (replace-regexp-in-string
     "{{\\(.*?\\)}}" 
     (lambda (r)
       (cdr (assoc (intern (match-string 1 r)) ctx)))
     tmpl
     )))

;; Example tc call
(let ;; Define some data
     ((params '(("name" "nicferrier")
                ("age" "30"))))
  (tc "<html><body><ul>{{paramlist}}</ul></body></html>\n"
      'paramlist (mapconcat 
                  (lambda (p)
                    (tc "<li>{{paramcar}}: {{paramcdr}}</li>"
                        'paramcar (car p)
                        'paramcdr (cadr p)))
                  params
                  "\n"
                  )
      ))
}}}

Neat! Everyone uses {{}} in their brace-based languages but a Lisp-y syntax might be ((…)) or ,(…)  . Also, any thoughts on directly expressing loops in the template language? --AmitPatel

[new]
I think nested parens are too common in text to make a good implementation choice. Braces seem like a good cultural choice anyway. Also I don't like explicit looping much.. I do like the idea of adding mapping or comprehensions, something like:

{{{
<html><body><ul>{{paramlist||<li>{{paramcar}}: {{paramcdr}}</li>}}</ul></body></html>
}}}

== Emacs in a screen terminal: colors ==
I do some remote pair programming inside screen. I would like to use emacs. Standard colors are too difficult for me to read (my eyes are going!).

vim has the very nice: 

{{{
set background=dark
}}}

which turns up the brightness on dark font faces. According to #emacs we have no equivalent.

So I wrote one:

{{{
(defvar dark-background nil)

(defun toggle-dark-background ()
  (interactive)
  (let ((difficult-colors
         '("red" "blue" "medium blue")))
    (mapc
     (lambda (face)
       (and (member (face-attribute face :foreground)  difficult-colors)
            (set-face-bold-p face (not dark-background))))
     (face-list)))
  (setq dark-background (not dark-background)))
}}}  

This toggles bold on the dark ones, which I think is all the vim thing is doing.

== Small Init Files ==

For a long time I've used a complex init file with loads of stuff in
it. This is great, it means emacs starts up with all my goodies. But
it also means when I go to another emacs I'm lost. It's also
non-trivial to move my stuff to another emacs.

I am trying to pair down my emacs use to the standard dist delivered
behaviour and then add obvious extras on top. This is a process I
started long ago but is still underway.

I've just discovered [[AutoInstall|auto install]] which helps greatly
in defining a smaller .emacs. Why? Because now I can keep the packages
I use in the EmacsWiki and just use auto-install to load them:

{{{
;; Nic's init file

(add-to-list 'load-path (expand-file-name "~/.emacs.d/"))
(require 'auto-install)

;; config stuff...
...
;; End
}}}

I have patched auto-install slightly. It's a very simple patch that
causes everything that has been auto-installed to be loaded on
startup:

{{{
;; Automatic loading

(defcustom auto-install-inhibit-startup-loading nil
  "Controls whether auto-installed packaged are loaded at startup.

If set to 't this inhibts the automatic loading of auto-load
files at startup. 

Otherwise all files in the 'auto-install-directory' are loaded
when auto-install is required."
  :type 'string
  :group 'auto-install)

(defun auto-install-on-startup ()
  "Require everything in the auto-install directory."
  (when (not auto-install-inhibit-startup-loading)
    (mapc (lambda (direntry)
            (let ((path (concat
                         (file-name-as-directory auto-install-directory)
                         direntry)))
              (when (and (file-readable-p path) 
                         (not (file-directory-p path))
                         (equal "el" (file-name-extension path)))
                (load-file path))))
          (directory-files auto-install-directory))))

;; Attempt to load all the auto-install files
(auto-install-on-startup)
}}}

Hopefully [[rubikitch]] will be able to add that to
auto-install. Ideally, it would do the kind of things that [[ELPA]]
does.

---- CategoryHomepage
