ELPA is the *Emacs Lisp Package Archive*, originally by TomTromey, now included in Emacs 24 after contributions from others.

== ELPA  ==
"Our goal is to make it simple to install, use, and upgrade Emacs Lisp packages. We supply ##package.el##, a simple package manager for Emacs, and a repository of pre-packed Emacs Lisp code."

##package.el## (from ELPA) has been added to vanilla GnuEmacs, version 24.  As of 2010-06-18, ##package.el## has been merged with the development version of Emacs, and an ELPA repository has been set up at http://elpa.gnu.org/.

The Emacs version of ##package.el## will support multiple repositories.  You can use the GNU ELPA plus other repositories like this:

  (setq package-archives '(("gnu" . "http://elpa.gnu.org/packages/")
                           ("marmalade" . "http://marmalade-repo.org/packages/")
                           ("melpa" . "http://melpa.milkbox.net/packages/")))

Any combination of repositories is fine.  You should probably always include GNU's core repository but it's not required.

You can add just one like this:

  (add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/"))

or for Melpa:

  (add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/"))

You can also customize these variables.


== How Packages work in Emacs 24 ==

[[http://www.gnu.org/software/emacs/manual/html_node/elisp/Packaging-Basics.html#Packaging-Basics|The Elisp Manual describes how the package system is initialized]]:

 Whenever Emacs starts up, it automatically calls the function
 package-initialize to load installed packages. This is done after
 loading the init file and abbrev file (if any) and before running
 after-init-hook (see Startup Summary). Automatic package loading is
 disabled if the user option package-enable-at-startup is nil.

So packages are initialized //AFTER// the init.el is loaded.  This means you should //NOT// put package specific initialization into your init.el except in a few ways:

* customization variables for a package are fine, they can be set before a package has loaded
* auto-mode-alist changes can be made in a way that does not require the package to be loaded before they are setup:

{{{
    (add-to-list 'auto-mode-alist '("\\.gradle" . groovy-mode))
}}}

* mode specific customization of a package could go in a package hook which can be set before the package is loaded, for example:

{{{
    (add-hook 'groovy-mode-hook (lambda () (setq tab-width 4)))
}}} 

* key bindings can also be done in such a way to not cause init failure, even if the package is not loaded:


{{{
    (global-set-key
     "\M-?"
     (lambda ()
       (interactive)
       (call-interactively 'magit-status)))

    (global-set-key (kbd "C-'")     'shell-switcher-switch-buffer)
}}}

* if all these tricks don't work you can still postpone config until after the packages have been loaded like this:

{{{
    (add-hook 'after-init-hook 'cycbuf-init)
}}}

Some people think that using //after-init-hook// seems like a last resort because it may force the load of the package you're referring to (thus slowing down Emacs). Others point out that moving your whole initialization to after ELPA is loaded makes things easier to use. 

You can do that by putting this in your init file:

{{{
(add-hook 'after-init-hook #'(lambda () (load "<real init file>")))
}}}

and moving all your normal init to the {{{<<real init file>>}}}. 

You can also move the customizations into their own init file, though that shouldn't matter, they could stay in your standard init file with the single {{{after-init-hook}}}. 

=== Adjusting load-path after updating packages ===

To my mind one of the faults of ELPA is that the load path is not updated when new packages are installed.  Here is a command that will do it for you:

{{{
(defun package-update-load-path ()
  "Update the load path for newly installed packages."
  (interactive)
  (let ((package-dir (expand-file-name package-user-dir)))
    (mapc (lambda (pkg)
            (let ((stem (symbol-name (car pkg)))
		  (version "")
		  (first t)
		  path)
	      (mapc (lambda (num)
		      (if first
			  (setq first nil)
			  (setq version (format "%s." version)))
		      (setq version (format "%s%s" version num)))
		    (aref (cdr pkg) 0))
              (setq path (format "%s/%s-%s" package-dir stem version))
              (add-to-list 'load-path path)))
          package-alist)))
}}}


=== ELPA policy ===

ELPA policy for Emacs 24 was discussed here: http://thread.gmane.org/gmane.emacs.devel/132634/focus=132640

== How packages work in Emacs 23 ==

You can make packages work in Emacs 23, you need to add something like this to your //init.el//:

{{{
(require 'package)
;; Any add to list for package-archives (to add marmalade or melpa) goes here
(add-to-list 'package-archives 
    '("marmalade" .
      "http://marmalade-repo.org/packages/"))
(package-initialize)
}}}


== Marmalade ==

[http://marmalade-repo.org/ Marmalade], a package.el friendly community package source that allows users to upload their own packages.  Package maintainers don't have to be the same as the maintainers of the original code.  

Some packages (for instance, slime) are out of date however.

NicFerrier maintains this repository.  He asks that you report issues or suggest features through the [[https://github.com/nicferrier/marmalade/issues|Github issues system]].

== Melpa ==

[http://melpa.milkbox.net/ MELPA] is a further package repository which hosts snapshot packages of many hundreds of libraries. Packages are built on the MELPA server directly from upstream source code according to small recipe files; in this sense MELPA is akin to a server-side version of el-get which eliminates the need for a user to have multiple version-control tools on his local machine.

Library authors do not need to upload new versions of their packages to MELPA, since they are built automatically. The MELPA maintainers plan to add support for automatic builds of stable version packages triggered by upstream version tags.

Currently supported backends are git, svn, bzr, hg, darcs and emacswiki. The collaboration model for MELPA is like that of the Homebrew package manager on OS X -- to add new recipes, simply file a pull request [https://github.com/milkypostman/melpa on Github].

Melpa uses a recipe system similar to [[el-get]].  Recipes are stored on a git-hub repository which tells the updated package.el how to download each package.  The source of the package might be from git, svn, darcs or this wiki.

== Other ==

AndrewHyatt has written an [http://code.google.com/p/elpa-on-appengine/ implementation of ELPA for AppEngine], written in Go.  It is not yet running publicly yet.

----
CategoryCode CategoryPackaging
