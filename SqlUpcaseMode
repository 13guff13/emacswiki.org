A minor mode which converts lower-case SQL keywords to upper-case as you type or otherwise insert text in the buffer -- for instance, killing and yanking an entire SQL query would upcase all keywords in that query.

It utilises the product-specific regexps defined by sql.el, and thus will upcase only the keywords defined for the buffer's `sql-product'. (Note that `sql-mode' buffers default to the `ansi' product.)

==Download==

Download the library from Lisp:sql-upcase-mode.el

==Install==

Place the library somewhere in your Emacs load-path (or use ##M-x package-install-file## for the downloaded file), and add the following to your init file:

 (when (require 'sql-upcase-mode nil :noerror)
   (add-hook 'sql-mode-hook 'sql-upcase-mode)
   (add-hook 'sql-interactive-mode-hook 'sql-upcase-mode))

==Configure==

By default, /only/ lower-case keywords are processed. ##(setq sql-upcase-mixed-case t)## to handle mixed-case keywords as well.

==Known issues==

# This is slightly aggressive in ##sql-interactive-mode##, in that text insertions in that mode are not always typed by the user. The biggest concern /is/ handled -- output from the inferior comint process is not touched. However there may be other cases (e.g. cycling through the comint command history) in which automatic modifications to the inserted text are less desirable. In practice this is probably ok, but YMMV.

# It is assumed that font-lock patterns using ##font-lock-builtin-face## are functions, and should only be upcased when followed by an opening parenthesis. In practice this is not always accurate (an example being that, for PostgreSQL, ##set## is treated as a 'builtin' rather than a 'keyword'). It may be better to treat both types the same, and not insist upon the opening parenthesis for builtins, but more investigation is needed.

# Contextual behaviour is limited to ignoring comments and strings, so if you have an identifier name in your query which is also a keyword, it will be upcased. If an unwanted upcasing occurs, you can use undo to revert to the original case.

# It's possible for ##(syntax-ppss)## to get confused in ##sql-interactive-mode##. I've observed a case where an unbalanced quote in earlier output caused ##sql-upcase-mode## to think everything subsequent was in a string, and so it was refraining from doing anything. Forcing another unbalanced quote into the buffer worked around the problem. I strongly suspect this issue can be resolved with constrained usage of ##(parse-partial-sexp)## (not looking further backwards than the most recent prompt or semicolon would seem the sensible thing to do).

# I'm aware of a couple of other bugs, which I'll fix very soon. Expect a new version over the weekend.

----
CategoryModes
CategorySql
