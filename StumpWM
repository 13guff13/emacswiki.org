[http://www.nongnu.org/stumpwm/ Stumpwm] is the Emacs of window managers.  If you're using it, you'll want to put a few thing in your .stumpwmrc.

== SLIME ==

If you've enabled multi-threading, add this code to your .stumpwmrc for interactive control of Stumpwm via Slime:
{{{
;; Load swank.
;; *prefix-key* ; swank will kick this off
(load "/path/to/slime/swank-loader.lisp")
(swank-loader:init)
(defcommand swank () ()
  (setf stumpwm:*top-level-error-action* :break)
  (swank:create-server :port 4005
                       :style swank:*communication-style*
                       :dont-close t)
  (echo-string (current-screen) 
	       "Starting swank. M-x slime-connect RET RET, then (in-package stumpwm)."))
(swank)
}}}

Multi-threading is available in SBCL, though [[http://bbs.archlinux.org/viewtopic.php?pid=434724#p434724 not in CLisp]].  Running Swank (or any other command that doesn't fork or exit) on a single-threaded StumpWM will hang StumpWM.  You'll be able to move the mouse, but the prefix key won't react anymore.  You'll have to Ctrl+Alt+Backspace to start a new session.  You can still hack using the StumpWM Eval functionality though.

== Controlling emacs through stumpwm commands ==

This is an example of how you can use stumpwm commands to call emacs functions.
{{{
(defcommand wanderlust () ()
	    (emacs)
	    (send-meta-key (current-screen) (kbd "M-x"))
	    (window-send-string "wl")
	    (send-meta-key (current-screen) (kbd "RET")))
}}}

==Loading swank from a quicklisp installation==

If, like me, you have installed slime through quicklisp then then /path/to/slime/swank-loader.lisp will not be fixed.  The code in the SLIME section works but it would have to be changed every time slime is updated.  Given /path/to/quicklisp/installation (in my case this is /home/consultant/quicklisp but your mileage will be different,) it is possible to auto-detect the correct path.  Replace (load "/path/to/slime/swank-loader.lisp") with:

{{{
;;
;; A helper function:
;;
(defun split-by-one-space (string)
    "Returns a list of substrings of string
divided by ONE space each.
Note: Two consecutive spaces will be seen as
if there were an empty string between them."
    (loop for i = 0 then (1+ j)
          as j = (position #\Space string :start i)
          collect (subseq string i j)
       while j))
;;
;; Set the path to the quicklisp installation:
;;
(defvar *quicklisp-installation-directory*
  "/path/to/quicklisp/installation"
  "The base of the quicklisp installation")
;;
;; Set path to installation data file:
;;
(defvar *quicklisp-data-file*
  (concat *quicklisp-installation-directory* "/dists/quicklisp/releases.txt")
  "Release and version data for quicklisp packages.")
;;
;; Set path to quicklisp software directory:
;;
(defvar *quicklisp-packages-directory*
  (concat *quicklisp-installation-directory* "/dists/quicklisp/software")
    "Path to the quicklisp packages")
  (setf *I-got-here* "*quicklisp-packages-directory*")

;;
;; Auto-detect /path/to/slime/swank-loader.lisp
;;
(defvar *swank-loader-path* nil
  "The path to swank-loader.lisp")
;;
(setf *swank-loader-path*
      (with-open-file (stream *quicklisp-data-file*)
	(loop
	   for line = (read-line stream nil :finished)
	   until (eq line :finished)
	   for data-list = (split-by-one-space line)
	   when (equal "slime" (first data-list)) do
	     (return (concat
		      *quicklisp-packages-directory*
		      "/" (sixth data-list)
		      "/swank-loader.lisp")))))
;;
;; Now load swank-loader.lisp (and carry on as before)
;;
(load *swank-loader-path*)
}}}

----
CategoryRelated
