[http://www.nongnu.org/stumpwm/ Stumpwm] is the Emacs of window managers.  If you're using it, you'll want to put a few thing in your .stumpwmrc.

== SLIME ==

If you've enabled multi-threading, add this code to your .stumpwmrc for interactive control of Stumpwm via Slime:
{{{
;; Load swank.
;; *prefix-key* ; swank will kick this off
(load "/path/to/slime/swank-loader.lisp")
(swank-loader:init)
(defcommand swank () ()
  (setf stumpwm:*top-level-error-action* :break)
  (swank:create-server :port 4005
                       :style swank:*communication-style*
                       :dont-close t)
  (echo-string (current-screen) 
	       "Starting swank. M-x slime-connect RET RET, then (in-package stumpwm)."))
(swank)
}}}

Multi-threading is available in SBCL, though [[http://bbs.archlinux.org/viewtopic.php?pid=434724#p434724 not in CLisp]].  Running Swank (or any other command that doesn't fork or exit) on a single-threaded StumpWM will hang StumpWM.  You'll be able to move the mouse, but the prefix key won't react anymore.  You'll have to Ctrl+Alt+Backspace to start a new session.  You can still hack using the StumpWM Eval functionality though.

== Controlling emacs through stumpwm commands ==

This is an example of how you can use stumpwm commands to call emacs functions.
{{{
(defcommand wanderlust () ()
  (emacs)
  (send-meta-key (current-screen) (kbd "M-x"))
  (window-send-string "wl")
  (send-meta-key (current-screen) (kbd "RET")))
}}}

== Loading swank from a quicklisp installation ==

If, like me, you have installed slime through quicklisp then then /path/to/slime/swank-loader.lisp will not be fixed.  The code in the SLIME section works but it would have to be changed every time slime is updated.  However in this case you can use quicklisp itself to load swank, by replacing the first two lines of code with:

{{{
;;
(ql:quickload :swank)
;;
}}}

== Security Issues ==

The usual way to connect to the swank server in emacs is with code like:

{{{
	(slime-connect "127.0.0.1" "4005")
}}}

Two things are worth noticing.  The first is that the port doesn't have to be 4005, it just has to be the same as the one defined in stumpwm.  With a multi-threaded Common Lisp like sbcl this means that you can have more than one swank server running.  The second thing to notice is that you don't have to use the localhost IP number, 127.0.0.1.  This means that an attacker could control your window manager from another machine.  You may wish to adjust the firewall settings on your machine to take this into account.

If your machine is a laptop that you use on many different networks, you may not wish to automatically start the swank server when stumpwm starts up.  If you replace the call to swank on the last line of the code with:

{{{
	(define-key *root-map* (kbd "C-s") "swank")
}}}

Then the key sequence "C-t C-s", which you can change if you like, will be bound to the command to start the server, but the server will not start up automatically.

Even better, you can amend the code for the command "swank" so that it toggles the server on/off as follows:

{{{
(let ((server-running nil))
  (defcommand swank () ()
    "Toggle the swank server on/off"
    (setf stumpwm:*top-level-error-action* :break)
    (if server-running
	(progn
	  (swank:stop-server 4005)
	  (echo-string
	   (current-screen)
	   "Stopping swank.")
	  (setf server-running nil))
	(progn
	  (swank:create-server :port 4005
			       :style swank:*communication-style*
			       :dont-close t)
	  (echo-string
	   (current-screen)
	   "Starting swank. M-x slime-connect RET RET, then (in-package stumpwm).")
	  (setf server-running t)))))
}}}

== Lazy Loading Swank ==

Since Swank is a fairly big package, it would be a good idea not to load it every time the StumpWM starts up.

=== The Problem ===

The "obvious" solution doesn't work.  If you write:

{{{
  (ql:quickload :swank)
  (swank:create-server :port 4005 ...
}}}

inside a function, you come across the problem that Common Lisp first loads a form and only then interprets it.  In a case like this, it will not know that swank:create-server exists when it first sees it as swank will not have been loaded.  If you are using SBCL then the problem is even more complicated as it incrementally compiles forms as they are loaded.  This is one of the few places where this behaviour of SBCL makes a real difference.

=== The Usual Solution ===

In most versions of Common Lisp, you can simply intern the symbol create-server as follows:

{{{
   (ql:quickload :swank)
   (funcall (intern "create-server" :swank) :port 4005 ....
}}}

The Lisp knows that create-swank is a function when the form is being loaded, and when the form is interpreted, swank has already loaded so the code does what you expect.

=== The Solution for SBCL ===

Since SBCL tries to compile a form when it is first loaded, this solution will not work.  The solution has to be more complex as somehow we must ensure that :swank is loaded before the call to the function even though it is not loaded at start-up.  One solution is the use stumpish, stumpwm's shell, to load the package.  Put the definition of the function is another file something like:

{{{
;; swank.lisp -*- Mode: Lisp -*-

;; Load swank
(ql:quickload :swank)
;;
(let ((server-running nil)
      (first-time t))
  ;;
  (defcommand swank () ()
    "Toggle the swank server on/off."
    (setf stumpwm:*top-level-error-action* :break)
    (if server-running
        (progn
          (swank:stop-server 4005)
          (echo-string
           (current-screen)
           "Stopping swank.")
          (setf server-running nil))
        (progn
          (swank:create-server :port 4005
                               :style swank:*communication-style*
                               :dont-close t)
	  (if first-time
            (echo-string
             (current-screen)
             "Re-starting swank.")
	    (setf first-time nil))
          (setf server-running t)))))
;; Now call the re-defined command
(swank)
}}}

Then in your .stumpwmrc put some code like:

{{{
(defcommand swank () ()
  "Turn on the swank server the first time.
Load a file that re-defines swank and then call it."
  (setf stumpwm:*top-level-error-action* :break)
  ;; Be careful with the quotes!
  (run-shell-command  "stumpish 'eval (load \"/path/to/swank.lisp\")'")
  (echo-string
   (current-screen)
   "Starting swank. M-x slime-connect RET RET, then (in-package stumpwm)."))
;;
(define-key *root-map* (kbd "C-s") "swank")
}}}

Note that the first time the command swank is called,  it's definition gets change to that in the loaded file.

All this assumes that stumpish is in your shells PATH but we again have the problem that the path to it changes every time stumpwm is updated with quicklisp.  One solution is to put the following shell script, also called stumpish but which sources the "real" stumpish, somewhere in your PATH:

{{{
#!/bin/bash
# stumpish
# This should always load the latest version of stumpish

# In my case /path/to/quicklisp is ${HOME}/quicklisp; your mileage may be different!

stump_start="/path/to/quicklisp"
stump_middle=$(cat ${stump_start}/dists/quicklisp/installed/releases/stumpwm.txt)
stump_end="contrib/stumpish"

stumpish=${stump_start}/${stump_middle}${stump_end}

# Note the `.' - the `real' stumpish must be sourced!

. ${stumpish}
}}}
----
CategoryRelated
