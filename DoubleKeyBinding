I saw this somewhere but can't remember where. This definition allows
me to press "End" to go to the end of the line and "End" again to go
to the end of the buffer.

Lisp:sequential-command.el
Lisp:sequential-command-config.el

[new]
'''See Also:'''

* `<code>beginning-of-line+</code>' and `<code>end-of-line+</code>' in Lisp:misc-cmds.el. They let you use `C-a' and `C-e' repeatedly to zip up & down the beginnings or ends of lines.

* DoReMi -- Use the arrow keys and the mouse wheel to repeat commands or execute a sequence of commands in sequence. -- DrewAdams
[new]

This was used because the function keys did not work with the meta key
with one PC and i got so used to it i still have in my standard
bindings. -- PeterMielke

  (defvar my-home-end-point nil
    "Position of point when the commands my-home and my-end were
  first called.")
  
  (defun my-home ()
    "Context sensitive home function. First call moves point to beginning of
  line. Second call moves point to beginning of buffer."
    (interactive)
    (cond ((eq last-command 'my-home)
           (goto-char my-home-end-point)
           (beginning-of-buffer))
          (t
           (setq my-home-end-point (point))
           (beginning-of-line))))
  
  (defun my-end ()
    "Context sensitive end function. First call moves point to end of line.
  Second call moves point to end of buffer."
    (interactive)
    (cond ((eq last-command 'my-end)
           (goto-char my-home-end-point)
           (end-of-buffer))
          (t
           (setq my-home-end-point (point))
           (end-of-line))))

this looks interesting. Here is what I'd use:

  (defmacro make-double-command (name args doc-string interactive
                                      first-form second-form)
    (let ((int-form (if (not interactive)
                        '(interactive)
                      (list 'interactive interactive))))
      `(progn
       (defun ,name ,args ,doc-string
         ,int-form
         (if (eq last-command this-command)
             ,(if (and (listp second-form) (> (length second-form) 1))
                  (cons 'progn second-form)
                second-form)
           ,first-form)))))
  (put 'make-double-command 'lisp-indent-function 2)
  ;; See DefMacro for an explanation of this call to put

  (make-double-command my-home ()
    "Go to beginning of line, or beginning of buffer." 
    nil
    (beginning-of-line)
    (beginning-of-buffer))

-- MarioLang


I use something similar to type character entity references in HTML. Check it:

 (defmacro ted-insert-char-entity-maybe (char entity)
   `(lambda ()
      (interactive)
      (let ((char-at-point (save-excursion
                             (backward-char 1)
                             (following-char))))
        (if (equal char-at-point ,char)
            (progn
              (backward-delete-char 1)
              (insert ,entity))
          (insert ,char)))))

 (add-hook 'html-mode-hook
           (lambda ()
             (define-key html-mode-map [(<)]
               (ted-insert-char-entity-maybe ?< "&amp;lt;"))
             (define-key html-mode-map [(>)]
               (ted-insert-char-entity-maybe ?> "&amp;gt;"))
             (define-key html-mode-map [(&)]
               (ted-insert-char-entity-maybe ?& "&amp;amp;"))
             (define-key html-mode-map [(\")]
               (ted-insert-char-entity-maybe ?\" "&amp;quot;"))))

[new]
[:rgb-insert-if-double]
|| This does the same thing with bit less code, plus prefix arg works.  Thanks for the idea. --[http://www.emacswiki.org/cgi-bin/wiki/Rick_Bielawski rgb]||

<pre>
 (defmacro rgb-insert-if-double (otherwise)
   "Insert OTHERWISE when the key mapped to this fcn is pressed twice.
  For example typing && can result in &amp;amp; appearing in place of &&.
  Use C-u <count> <key> to insert <key> more than once without replace."
   `(lambda (cnt raw)
      (interactive "p\nP")
      (if (and (equal (preceding-char) last-command-char)
               (not raw))
          (progn
              (backward-delete-char 1)
              (insert ,otherwise))
          (self-insert-command cnt))))
 
(add-hook 'html-mode-hook
 (lambda ()
   (define-key html-mode-map [(<)]  (rgb-insert-if-double "&amp;lt;"))
   (define-key html-mode-map [(>)]  (rgb-insert-if-double "&amp;gt;"))
   (define-key html-mode-map [(&)]  (rgb-insert-if-double "&amp;amp;"))
   (define-key html-mode-map [(\")] (rgb-insert-if-double "&amp;quot;"))))
</pre>
[new]
I use the fallowin function for sequence commands:

 ;; Sequence commands  1.0
 (defvar seq-store-times 0)
 (defvar seq-start-point 0
   "Stores location of pointer when sequence of calls of the same
 function was started. This variable is updated by `seq-times'")

 (defun seq-times (name &optional max)
   "Returns number of times command `name' was executed. If `max'
 is specified the counter will wrap around at the value of `max'
 never reaching it. It also updates `seq-start-point'."
   (if (eq last-command name)
       (if (= (setq seq-store-times (1+ seq-store-times)) max)
           (setq seq-store-times 0) seq-store-times)
     (setq seq-start-point (point) seq-store-times 0)))


Now creating double- and more- commands is soo easy:

 (defun my-home ()
    "Depending on how many times it was called moves the point to:
 once - beginning of line; twice - indent;
 three times - beginning of buffer; four times - back to where it was."
    (interactive)
    (let ((n (seq-times 'my-home 4)))
      (cond ((= n 0) (beginning-of-line))
            ((= n 1) (back-to-indentation))
            ((= n 2) (beginning-of-buffer))
            (t (goto-char seq-start-point)))))

 (defun my-end () "Go to end of line or buffer" (interactive)
   (let ((n (seq-times 'my-end 3)))
     (cond ((= n 0) (end-of-line))
           ((= n 1) (end-of-buffer))
           (t (goto-char seq-start-point)))))

It would be even simpler if there is a way of getting the name of function which called the executing one. -- mina86

[new]
: Functions don't need to have names and sometimes they have more than one name so what you want might be ambiguous or even nonexistent.  (eq last-command name) can probably be replaced with (eq last-command this-command) if that's what you were looking to do.

[new]
These are re-implemented in Lisp:sequential-command.el and Lisp:sequential-comand-config.el . See `seq-home' and `seq-end'. -- [[rubikitch]]

[new]
'''Related Pages:'''
* ElectricDotAndDash

[new:rubikitch:2008-11-05 10:12 UTC]
'''Electric upcase/capitalize/downcase'''

See Lisp:sequential-comand-config.el .

I bound M-u/M-c/M-l to seq-(upcase|capitalize|downcase)-backward-word. -- [[rubikitch]]
----
CategoryKeys



