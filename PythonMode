There are two implementations of a Python mode for Emacs. 

(RichardRiley : this is a very, very confusing page. It's hard to make head nor tail of what could and should be used in emacs 23 and I will try to annotate/clip this page when I know more. The whole python.el v python-mode.el thing is really messy)
: Couldn't agree more. I wanted to program in python with emacs, but getting my python-mode just right with all the feature has been a pain - This page is a bit of a mess of information - maybe we could collaborate to make a page that gives easier instruction for creating a usable python configuration?
How about PythonProgrammingInEmacs --CH
:: I've had no replies from anyone about the changes I've proposed to the structure of this page, in the meanwhile this page, and the ones I've created will just diverge; Should I just delete this page and redirect it to PythonProgrammingInEmacs ? --CH

== python-mode.el ===

python-mode.el is part of the Python distribution.  You can also download it from launchpad:

* https://launchpad.net/python-mode

The relevant page also has installation instructions.  The following was enough for me, though:

* Add python-mode.el to the LoadPath.
* Add the following to your InitFile

 (autoload 'python-mode "python-mode" "Python Mode." t)
 (add-to-list 'auto-mode-alist '("\\.py\\'" . python-mode))
 (add-to-list 'interpreter-mode-alist '("python" . python-mode))

this could be useful: (RichardRiley : why?)

 (add-hook 'python-mode-hook
           (lambda ()
             (set (make-variable-buffer-local 'beginning-of-defun-function)
                  'py-beginning-of-def-or-class)
             (setq outline-regexp "def\\|class ")))

Fixes for deficiencies and problems with it in Emacs are at
* http://www.loveshack.ukfsn.org/emacs/python-mode.el.diff

They were submitted, but I don't think they got used.  I don't know of
any reason to use it (as opposed to python.el) with Emacs.


== python.el ===

Emacs post version 21 has its own python mode (python.el). This is enabled by default for .py files so you don't have to add anything to your InitFile to use it.  It contains properly-integrated support for things
like completion, symbol help, eldoc, and inferior interpreter features.

* GIT:progmodes/python.el

The version in Emacs 22 has a bunch of problems.  Use
* http://www.loveshack.ukfsn.org/emacs/python.el
It requires
* http://www.loveshack.ukfsn.org/emacs/emacs.py
and
* http://www.loveshack.ukfsn.org/emacs/sym-comp.el

There's a version of this hacked up up to run (with some missing features
and bugs) in Emacs 21 at
* http://www.loveshack.ukfsn.org/emacs/python-21.el

It requires sym-comp.el as above, and Emacs 22's syntax.el:
* GIT:emacs-lisp/syntax.el

It also requires emacs.py (as above) either in data-directory
or somewhere else Python can find it.

[new]
I'm a little confused - It appears when I set flymake-mode to be automatically on for python mode, py-help-at-point doesn't work.
I tried switching from python-mode.el to python.el, but not this doesn't seem to solve it;
However, there is no advice here on *how* to use python.el, so I'm not entirely sure I'm doing it right...
-> Have you tried to first run the Python interpreter (C-c !)?
[new]

In python-mode.el RET is bound to py-newline-and-indent, which  indents the next line if necessary.  In python.el this is bound to C-j instead.  You can get the previous behavior with this in your InitFile:

 (add-hook 'python-mode-hook '(lambda () (define-key python-mode-map "\C-m" 'newline-and-indent)))

Using python-complete-symbol in the inferior python buffer causes an infinite loop in python.el as of 080117, changing python-imports from the default nil to 'None' solves this. 2008-01-17, patch submitted.

: The above refers to python.el as packaged with Emacs 22. In the loveshack- python.el completion can't generally work in the inferior buffer because it sends input to that buffer.  The loveshack- python.el doesn't actually define python-complete-symbol.  You can use the interpreter rlcompleter module as normal if you want.

== some more commands ==

 (defun py-next-block ()
   "go to the next block.  Cf. `forward-sexp' for lisp-mode"
   (interactive)
   (py-mark-block nil 't)
   (back-to-indentation))

: python.el has python-end-of-block.

== Comment/Uncomment Region ==

If you have `transient-mark-mode' on, you can just use `comment-dwim': select a region and hit `M-;'.  The DoWhatIMean means that it will comment or uncomment the region as appropriate.  If you do not have `transient-mark-mode' on by default, you can hit C-SPC twice to activate it temporarily.

You can also use "rectangles" to comment or uncomment mode (among other things that you can do with rectangles).  See RectangleCommands or "(emacs) Rectangles" in the Emacs manual.  To get to that part of the manual, hit the following keys in Emacs: M-: (info "(emacs) Rectangles") RET.

== Get the python documentation on the function/module at point ==

ElDoc works with the python mode in GNU Emacs 22.
(For Emacs 21, see the [http://www.loveshack.ukfsn.org/emacs/eldoc.el back-port] of Eldoc.)
To enable it by default in your python mode buffers, you might want something like:

   (add-hook 'python-mode-hook
          '(lambda () (eldoc-mode 1)) t)

Here is how to get the internal python documentation on the function at point:

  (defun my-python-documentation (w)
    "Launch PyDOC on the Word at Point"
    (interactive
     (list (let* ((word (thing-at-point 'word))
                                (input (read-string 
                                                (format "pydoc entry%s: " 
                                                                (if (not word) "" (format " (default %s)" word))))))
                   (if (string= input "") 
                           (if (not word) (error "No pydoc args given")
                                 word) ;sinon word
                         input)))) ;sinon input
    (shell-command (concat py-python-command " -c \"from pydoc import help;help(\'" w "\')\"") "*PYDOCS*")
    (view-buffer-other-window "*PYDOCS*" t 'kill-buffer-and-window))
  
[new]
python-mode.el already has py-help-at-point for this, and python.el's
python-describe-symbol tries to get doc in the context of what the
source file imports (be sure to first run the Python interpreter [C-c !]).

Emacs23 and python-mode.el:

C-c C-f	"sys" -- this works, and describes the "sys" module in a separate Emacs help buffer.

If I define function "zoot", help doesn't on it -- it's only for global things.


== Search the python documentation in Emacs ==

Search the python online/offline documentations with convenience in Emacs

Github : http://github.com/tsgates/pylookup

Pylookup Mode : http://taesoo.org/Opensource/Pylookup

== Using flymake with pylint, pychecker, and pep8.py == 
(Here is an extended, cleaned up and bug-fixed version of the script below: 
http://bitbucket.org/tavisrudd/pylint_etc_wrapper.py/src/tip/pylint_etc_wrapper.py 
--Tavis Rudd, *not* the original author)

This is a script which runs and parses the output of various
Python code checking programs to work with flymake.  It has 
lots of issues, one being that flymake does not seem to show 
more than one error message per line of code, meaning that
an error or warning which is intentionally left unfixed can
mask an error or warning that would get more attention.

Additionally, the scripts which check python code are either 
rather anemic, and don't notice too much (pychecker) or are 
aggressive, and warn about all sorts of things that they 
should not (pylint).  pep8.py tends to be annoyingly aggressive
about whitespace.  

You must have pep8.py, pychecker and pylint in PATH for this script
to find them.  Additionally this script attempts to support 
virtual environments, but this is largely untested.

    import os
    import re
    import sys

    from subprocess import Popen, PIPE


    class LintRunner(object):
        """ Base class provides common functionality to run
              python code checkers. """

        sane_default_ignore_codes = set([])
        command = None
        output_matcher = None

        #flymake: ("\\(.*\\) at \\([^ \n]+\\) line \\([0-9]+\\)[,.\n]" 2 3 nil 1)
        #or in non-retardate: r'(.*) at ([^ \n]) line ([0-9])[,.\n]'
        output_format = "%(level)s %(error_type)s%(error_number)s:" \
                        "%(description)s at %(filename)s line %(line_number)s."

        def __init__(self, virtualenv=None, ignore_codes=(),
                     use_sane_defaults=True):
            if virtualenv:
                # This is the least we can get away with (hopefully).
                self.env = {'VIRTUAL_ENV': virtualenv,
                            'PATH': virtualenv + '/bin:' + os.environ['PATH']}
            else:
                self.env = None

            self.virtualenv = virtualenv
            self.ignore_codes = set(ignore_codes)
            self.use_sane_defaults = use_sane_defaults

        @property
        def operative_ignore_codes(self):
            if self.use_sane_defaults:
                return self.ignore_codes ^ self.sane_default_ignore_codes
            else:
                return self.ignore_codes

        @property
        def run_flags(self):
            return ()

        @classmethod
        def fixup_data(cls, line, data):
            return data

        @classmethod
        def process_output(cls, line):
            m = cls.output_matcher.match(line)
            if m:
                fixed_data = dict.fromkeys(('level', 'error_type',
                                            'error_number', 'description',
                                            'filename', 'line_number'),
                                           '')
                fixed_data.update(cls.fixup_data(line, m.groupdict()))
                print cls.output_format % fixed_data

        def run(self, filename):
            args = [self.command]
            args.extend(self.run_flags)
            args.append(filename)

            process = Popen(args, stdout=PIPE, stderr=PIPE, env=self.env)

            for line in process.stdout:
                self.process_output(line)


    class PylintRunner(LintRunner):
        """ Run pylint, producing flymake readable output.

        The raw output looks like:
          render.py:49: [C0301] Line too long (82/80)
          render.py:1: [C0111] Missing docstring
          render.py:3: [E0611] No name 'Response' in module 'werkzeug'
          render.py:32: [C0111, render] Missing docstring """

        output_matcher = re.compile(
            r'(?P<filename>[^:]+):'
            r'(?P<line_number>\d+):'
            r'\s*\[(?P<error_type>[WECR])(?P<error_number>[^,]+),'
            r'\s*(?P<context>[^\]]+)\]'
            r'\s*(?P<description>.*)$')

        command = 'pylint'
        sane_default_ignore_codes = set([
            "C0103",  # Naming convention
            "C0111",  # Missing Docstring
            "E1002",  # Use super on old-style class
            "W0232",  # No __init__
            #"I0011",  # Warning locally suppressed using disable-msg
            #"I0012",  # Warning locally suppressed using disable-msg
            #"W0511",  # FIXME/TODO
            #"W0142",  # *args or **kwargs magic.
            "R0904",  # Too many public methods
            "R0903",  # Too few public methods        
            "R0201",  # Method could be a function
            ])

        @classmethod
        def fixup_data(cls, line, data):
            if data['error_type'].startswith('E'):
                data['level'] = 'ERROR'
            else:
                data['level'] = 'WARNING'
            return data

        @property
        def run_flags(self):
            return ('--output-format', 'parseable',
                    '--include-ids', 'y',
                    '--reports', 'n',
                    '--disable-msg=' + ','.join(self.operative_ignore_codes))


    class PycheckerRunner(LintRunner):
        """ Run pychecker, producing flymake readable output.

        The raw output looks like:
          render.py:49: Parameter (maptype) not used
          render.py:49: Parameter (markers) not used
          render.py:49: Parameter (size) not used
          render.py:49: Parameter (zoom) not used """

        command = 'pychecker'

        output_matcher = re.compile(
            r'(?P<filename>[^:]+):'
            r'(?P<line_number>\d+):'
            r'\s+(?P<description>.*)$')

        @classmethod
        def fixup_data(cls, line, data):
            #XXX: doesn't seem to give the level
            data['level'] = 'WARNING'
            return data

        @property
        def run_flags(self):
            return '--no-deprecated', '-0186', '--only', '-#0'


    class Pep8Runner(LintRunner):
        """ Run pep8.py, producing flymake readable output.

        The raw output looks like:
          spiders/structs.py:3:80: E501 line too long (80 characters)
          spiders/structs.py:7:1: W291 trailing whitespace
          spiders/structs.py:25:33: W602 deprecated form of raising exception
          spiders/structs.py:51:9: E301 expected 1 blank line, found 0 """

        command = 'pep8.py'
        # sane_default_ignore_codes = set([
        #     'RW29', 'W391',
        #     'W291', 'WO232'])

        output_matcher = re.compile(
            r'(?P<filename>[^:]+):'
            r'(?P<line_number>[^:]+):'
            r'[^:]+:'
            r' (?P<error_number>\w+) '
            r'(?P<description>.+)$')

        @classmethod
        def fixup_data(cls, line, data):
            if 'W' in data['error_number']:
                data['level'] = 'WARNING'
            else:
                data['level'] = 'ERROR'

            return data

        @property
        def run_flags(self):
            return '--repeat', '--ignore=' + ','.join(self.ignore_codes)


    if __name__ == '__main__':
        from optparse import OptionParser
        parser = OptionParser()
        parser.add_option("-e", "--virtualenv",
                          dest="virtualenv",
                          default=None,
                          help="virtualenv directory")
        parser.add_option("-i", "--ignore_codes",
                          dest="ignore_codes",
                          default=(),
                          help="error codes to ignore")
        options, args = parser.parse_args()

        pylint = PylintRunner(virtualenv=options.virtualenv,
                              ignore_codes=options.ignore_codes)
        pylint.run(args[0])

        pychecker = PycheckerRunner(virtualenv=options.virtualenv,
                                    ignore_codes=options.ignore_codes)
        pychecker.run(args[0])

        pep8 = Pep8Runner(virtualenv=options.virtualenv,
                          ignore_codes=options.ignore_codes)
        pep8.run(args[0])
        sys.exit()


== Using flymake with pylint ==

[new]
Please note that pylint now comes with an executable "epylint" that is meant to be the interface to Emacs.
[new:Anonymous:2010-03-31 15:16 UTC]


The flymake mode in Emacs 22 does not understand Python, but it can be
made to work with [http://www.logilab.org/projects/pylint pylint].  To
do this, first you'll need to create a script somewhere along your
PATH called 'epylint'.  That script is:

    #!/usr/bin/env python
    
    import re
    import sys
    
    from subprocess import *
    
    p = Popen("pylint -f parseable -r n --disable-msg-cat=C,R %s" %
              sys.argv[1], shell = True, stdout = PIPE).stdout
    
    for line in p:
        match = re.search("\\[([WE])(, (.+?))?\\]", line)
        if match:
            kind = match.group(1)
            func = match.group(3)

	    if kind == "W":
	       msg = "Warning"
	    else:
	       msg = "Error"
    
            if func:
                line = re.sub("\\[([WE])(, (.+?))?\\]",
                              "%s (%s):" % (msg, func), line)
            else:
                line = re.sub("\\[([WE])?\\]", "%s:" % msg, line)
        print line,
    
    p.close()

It might appear that for some combinations of flymake, pylint and epylint
the above script might not work properly (it didn't for me). Debugging showed that
the regexp wasn't matching the output of pylint, ever, so the lines were being
printed from pylint verbatim, meaning that flymake was doing a "best effort"
match, and everything was coming up as an error, even minor warnings.

Here is an alternative version of the epylint script that works great for me.
It doesn't throw away all the R and C errors, just the most annoying ones. You can easily
modify it to include or exclude messages to your preference. I find it easier to have
the messages in the script rather than messing about with .pylintrc and the like

{{{

    #!/usr/bin/env python

    import re
    import sys

    from subprocess import Popen, PIPE

    ignore = ",".join ( [
        "C0103",  # Naming convention
        "I0011",  # Warning locally suppressed using disable-msg
        "I0012",  # Warning locally suppressed using disable-msg
        "W0511",  # FIXME/TODO
        "W0142",  # *args or **kwargs magic.
        "R0904",  # Too many public methods
        "R0201",  # Method could be a function
    ] )

    cmd = "pylint --output-format parseable --include-ids y --reports n --disable-msg=%s %s" % \
        ( ignore, sys.argv[1], )

    p = Popen ( cmd, shell = True, bufsize = -1,
                stdin = PIPE, stdout = PIPE, stderr = PIPE, close_fds = True )

    pylint_re = re.compile (
        '^([^:]+):(\d+):\s*\[([WECR])([^,]+),\s*([^\]]+)\]\s*(.*)$'
        )

    for line in p.stdout:
        line = line.strip()
        m = pylint_re.match ( line )
        if m:
            filename, linenum, errtype, errnum, context, description = m.groups()

            if errtype == "E":
                msg = "Error"
            else:
                msg = "Warning"

            # Here we are targetting the following flymake regexp:
            #
            #  ("\\(.*\\) at \\([^ \n]+\\) line \\([0-9]+\\)[,.\n]" 2 3 nil 1)
            #
            # where the number at the end indicate the index into the regexp
            # groups of ( file, line, column, error text )
            #
            # You can see what regexps flymake uses to parse its output by   
            # running 'M-x describe-variable' on the variable
            # 'flymake-err-line-patterns'
    
            print "%s %s%s %s at %s line %s." % ( msg, errtype, errnum,
                                                  description, filename, linenum )
}}}

(I've also got a version that inserts the overall code quality metric, as determined
by pylint, so you can see at a glance how close you are to pylint perfection; holler
here if you want to see it).
    
Once you test that this works on sample Python files, then add the
following to your InitFile to enable flymake checking of Python scripts
using pylint:

    (when (load "flymake" t)
      (defun flymake-pylint-init ()
        (let* ((temp-file (flymake-init-create-temp-buffer-copy
                           'flymake-create-temp-inplace))
           (local-file (file-relative-name
                        temp-file
                        (file-name-directory buffer-file-name))))
          (list "epylint" (list local-file))))
    
      (add-to-list 'flymake-allowed-file-name-masks
               '("\\.py\\'" flymake-pylint-init)))

Now if you turn on `flymake-mode' inside a Python file, you should see
lines with warnings highlighted in blue, and lines with errors
highlighted in red.  Just hover your mouse over either type of line
for a few seconds and you'll see a tooltip describing the
error/warning.  Plus, the modeline will show you two numbers, X/Y,
where X is the number of errors in your script, and Y is the total
number of warnings. -- JohnWiegley

You can customise the way flymake highlights your Python by running
'M-x customize-face' on 'flymake-errline' or 'flymake-warnline'. For
example, you can remove the background highlight and make the face
be just a subtle coloured underline.

== Using flymake with pyflakes ==

Found a desciption on how to use this pair at http://www.plope.com/Members/chrism/flymake-mode
I did a copy 'n paste for simplicity.

{{{
(when (load "flymake" t) 
  (defun flymake-pyflakes-init () 
     ; Make sure it's not a remote buffer or flymake would not work
     (when (not (subsetp (list (current-buffer)) (tramp-list-remote-buffers)))
      (let* ((temp-file (flymake-init-create-temp-buffer-copy 
                         'flymake-create-temp-inplace)) 
             (local-file (file-relative-name 
                          temp-file 
                          (file-name-directory buffer-file-name)))) 
        (list "pyflakes" (list local-file)))))
  (add-to-list 'flymake-allowed-file-name-masks 
               '("\\.py\\'" flymake-pyflakes-init))) 
}}}

There are some comments regarding using flymake-cursor to show the error in minibuffer [http://paste.lisp.org/display/60617,1/raw flymake-cursor.el] (the same idea is now available in [NxhtmlMode nXhtml] in the file <b>util/flymakemsg.el</b>).

== Integrating python-mode's pdbtrack with xpdb and making it aware of generator expressions ==

AlexCoventry

I have found the following settings helpful in using xpdb:

{{{
;; Let python-mode know about xpdb and generator expressions.
(setq py-pdbtrack-input-prompt "\n[(<]*x?pdb[>)]+ "
      py-pdbtrack-stack-entry-regexp
      (concat "^> \\(.*\\)(\\([0-9]+\\))"
	      "\\([?a-zA-Z0-9_]+\\|<genexpr>\\)()"))
}}}

xpdb is a fork of the standard library pdb, available here: https://code.launchpad.net/~eyal-lotem+launchpad/xpdb/main

== other things you may be interested in ==

: Only for ##python-mode.el##, presumably.

* Some rudimentary completion support is available from http://www.python.org/cgi-bin/moinmoin/EmacsPythonCompletion
* use C-c ! to start ipython instead of python: http://ipython.scipy.org/
* press F1 to check your code with pylint: http://www.logilab.org/projects/pylint
* Pretty good completion and refactoring support from: http://rope.sourceforge.net/ropemacs.html
* Debugging within Emacs: PdbNotes
* Another debugger, which contains Emacs interface: pydb (http://bashdb.sourceforge.net/pydb/). It even has multiple-windows interface :)
* Python autocompletion using pycomplete: http://groups.google.com/group/comp.lang.python/msg/048168c675ff0c68
* More on completion: http://www.rwdev.eu/articles/emacspyeng
* Yasnippet: http://code.google.com/p/yasnippet/ for Python, Django, django-templates snippets

Note: In regard to Yasnippet, see [http://groups.google.com/group/smart-snippet/browse_thread/thread/d1eae085ceebf839 this post] if using Dave Love's python.el

: For ##python-mode.el## or ##python.el##:

* PyIndent

== Issues ==
This is a known bug (emacs 21.3): python-mode interferes with gud in such a way as to make the overlay arrow not work when debugging (even C source).

Disable auto-loading python-mode to get around this bug.

: This is one of the things fixed by the patch to python-mode.el mentioned above.

== iPython Emacs 23 ==

RichardRiley

I found this which got me up and running with iPython integrated nicely into emacs 23. 

http://lists.ipython.scipy.org/pipermail/ipython-user/2008-September/005791.html

The important file, ipython.el, can be found here : http://ipython.scipy.org/dist/ipython.el

If you load it, ipython becomes the default python shell assuming the ipython executable is available.

my python integration is now like this:

<pre>
(setq load-path
      (append (list nil
                    "~/.emacs.d/python-mode-1.0/"
		    "~/.emacs.d/pymacs/"
		    "~/.emacs.d/ropemacs-0.6"
                    )
              load-path))

(require 'ipython)
(setq py-python-command-args '( "-colors" "Linux"))

(require 'python-mode)

(require 'pymacs)
(pymacs-load "ropemacs" "rope-")

;; (defadvice py-execute-buffer (around python-keep-focus activate)
;;   "Thie advice to make focus python source code after execute command `py-execute-buffer'."
;;   (let ((remember-window (selected-window))
;;         (remember-point (point)))
;;     ad-do-it
;;     (select-window remember-window)
;;     (goto-char remember-point)))

;; (defun rgr/python-execute()
;;   (interactive)
;;   (if mark-active
;;       (py-execute-string (buffer-substring-no-properties (region-beginning) (region-end)))
;;     (py-execute-buffer)))

;; (global-set-key (kbd "C-c C-e") 'rgr/python-execute)

(add-hook 'python-mode-hook
          '(lambda () (eldoc-mode 1)) t)

(provide 'python-programming)
</pre>

More iPython info here: http://ipython.scipy.org/moin/FrontPage

My own python files are here : http://richardriley.net/projects/emacs/dotprogramming#sec-1.4

Having got iPython working in emacs, I found the following "howto tutorial" videos to be superb for the beginner (me!) :

http://showmedo.com/videos/video?name=1000010&fromSeriesID=100
(This does not seem to work with Firefox. Can't we try to use something that works with Firefox instead of something that only works with IE?)

== Ipython completion ==

Ipython provide good completion support without extra dependencies.

However, to make it working in emacs, you will have to add this line to your .emacs:

<pre>
(setq ipython-completion-command-string "print(';'.join(__IP.Completer.all_completions('%s')))\n")
</pre>

The definition in ipython.el is wrong (or deprecated may be).

Note that Lisp:anything-ipython.el already fix this.

To have an even better completion, you should install also rlcompleter2.

http://codespeak.net/rlcompleter2/

Lisp:anything-ipython.el provide an anything interface for ipython completion in your python buffer.

You will find all instructions to install Lisp:anything-ipython.el in the headers of file.

You will need of course a complete Anything install, look how to install Anything at

http://www.emacswiki.org/cgi-bin/emacs/Anything

Screenshot of anything-ipython in action:

http://farm4.static.flickr.com/3459/3760695525_887356961c.jpg

-- ThierryVolpiatto

Q: How does this compare to rope and the other myriad of completion methods. company-mode compares how?

== Ipython debugging/pdbtrack ==

I made the following changes to python-mode.el to make debugging work again with current IPython (0.9.1):

[...]

 ;; pdbtrack constants
 (defconst py-pdbtrack-stack-entry-regexp
  "^> \\(.*\\)(\\([0-9]+\\))\\([?a-zA-Z0-9_<>]+\\)()"; this is new
 ;  "^> \\([^(]+\\)(\\([0-9]+\\))\\([?a-zA-Z0-9_]+\\)()"
 ;  "^> \\(.*\\)(\\([0-9]+\\))\\([?a-zA-Z0-9_]+\\)()"
   "Regular expression pdbtrack uses to find a stack trace entry.")
 
 ;(defconst py-pdbtrack-input-prompt "\n[(<]*[Pp]db[>)]+ "
 (defconst py-pdbtrack-input-prompt "\n[(<]*[Ii]?[Pp]db[>)]+ "; this is new
   "Regular expression pdbtrack uses to recognize a pdb prompt.")

[...]

            (py-pdbtrack-overlay-arrow nil)

          (setq block (ansi-color-filter-apply block)) ; this is new
          (setq target (py-pdbtrack-get-source-buffer block))

[...]

Now when I debug in the IPython console (using %run -d, or %pdb on, etc.) pdbtrack makes sure to show me the current source code and corresponding line. Note that these changes may break debugging in a standard python-shell, I have not tested this.



----
ProgrammingModes
