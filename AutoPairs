It can be useful to insert parentheses, braces, quotes and the like in matching pairs -- e.g., pressing "##(##" inserts '##()##', with the cursor in between. In the TextMate editor, this is called "auto-paired characters".

== Simple auto-pairing ==

The [SkeletonMode Skeleton library] provides pair insertion via the ##skeleton-insert-maybe## command, which can be bound to the opening key:

    (setq skeleton-pair t)
    (global-set-key "(" 'skeleton-pair-insert-maybe)
    (global-set-key "[" 'skeleton-pair-insert-maybe)
    (global-set-key "{" 'skeleton-pair-insert-maybe)

The ##skeleton-pair## variable must be non-##nil## for pairing to occur. Pairing is possible with all characters. By default, '##(##', '##[##', '##{##', '##<##' and '##`##' all pair with the symmetrical character. This behavior can be modified by the variable ##skeleton-pair-alist##.

Skeletons also work with selections -- typing the opening character will wrap the selected text in the opening and closing characters.

== Better pairing ==

<tt>[http://code.google.com/p/emacs-textmate/ textmate.el]</tt> extends the pairing behavior: the cursor "moves over" closing characters instead of inserting new ones, and empty pairs like '##()##' are deleted with a single keypress. ParEdit, a minor mode for Lisp-like languages, also provides both these features.

'''As a fall-back, you may place the (more general) code below in <tt>[InitFile .emacs]</tt>:'''

    (setq skeleton-pair t)
    (setq skeleton-pair-alist
          '((?\( _ ?\))
            (?[  _ ?])
            (?{  _ ?})
            (?\" _ ?\")))

    (defun autopair-insert (arg)
      (interactive "P")
      (let (pair)
        (cond
         ((assq last-command-char skeleton-pair-alist)
          (autopair-open arg))
         (t
          (autopair-close arg)))))

    (defun autopair-open (arg)
      (interactive "P")
      (let ((pair (assq last-command-char
                        skeleton-pair-alist)))
        (cond
         ((and (not mark-active)
               (eq (car pair) (car (last pair)))
               (eq (car pair) (char-after)))
          (autopair-close arg))
         (t
          (skeleton-pair-insert-maybe arg)))))

    (defun autopair-close (arg)
      (interactive "P")
      (cond
       (mark-active
        (let (pair open)
          (dolist (pair skeleton-pair-alist)
            (when (eq last-command-char (car (last pair)))
              (setq open (car pair))))
          (setq last-command-char open)
          (skeleton-pair-insert-maybe arg)))
       ((looking-at
         (concat "[ \t\n]*"
                 (regexp-quote (string last-command-char))))
        (replace-match (string last-command-char))
        (indent-according-to-mode))
       (t
        (self-insert-command (prefix-numeric-value arg))
        (indent-according-to-mode))))

    (defun autopair-backspace (arg)
      (interactive "p")
      (if (eq (char-after)
              (car (last (assq (char-before) skeleton-pair-alist))))
          (and (char-after) (delete-char 1)))
      (delete-backward-char arg))

    (global-set-key [backspace] 'autopair-backspace)

    (global-set-key "("  'autopair-insert)
    (global-set-key ")"  'autopair-insert)
    (global-set-key "["  'autopair-insert)
    (global-set-key "]"  'autopair-insert)
    (global-set-key "{"  'autopair-insert)
    (global-set-key "}"  'autopair-insert)
    (global-set-key "\"" 'autopair-insert)
    ;; ...

The ##autopair-insert## command is bound to both the opening and closing keys. To add a new pair, extend ##skeleton-pair-alist## as such:

    (add-to-list 'skeleton-pair-alist '(?<  _ ?>))

and bind ##autopair-insert## to the necessary key(s).

[new]
The above code has been made into a package [http://github.com/ramblex/emacs-textmate here]. It has a few neat little extras such as being able to turn off the pairing of some characters in some modes.

=== autopair.el ===

Try out [http://autopair.googlecode.com/svn/trunk/autopair.el autopair.el] hosted in http://autopair.googlecode.com for yet another approach:

* it's a little less intrusive than some other extensions since it preserves the original bindings for the keys it rebinds;
* discovers which characters to pair based on the currently active syntax table;
* tries to do autopairing/autoskipping in a way that will contribute to balancing out the parenthesis.

[new]
How does this work? Does it make use of command loop hooks?

=== CC Mode ===

To use these commands in [CcMode CC Mode]:

    (defun autopair-close-block (arg)
      (interactive "P")
      (cond
       (mark-active
        (autopair-close arg))
       ((not (looking-back "^[[:space:]]*"))
        (newline-and-indent)
        (autopair-close arg))
       (t
        (autopair-close arg))))

    (add-hook 'c-mode-common-hook
              '(lambda ()
                 (local-set-key "(" 'autopair-insert)
                 (local-set-key ")" 'autopair-insert)
                 (local-set-key "{" 'autopair-insert)
                 (local-set-key "}" 'autopair-close-block)))

The ##autopair-close-block## command ensures that ##}##'s are placed on separate lines.

== Electric RET ==

: '''[http://img8.imageshack.us/img8/9479/openparen.gif Short video demonstration]'''

Similar to the "electric" behavior of [CcMode CC Mode], ##RET## can be made to place an empty line between the opening and closing characters:

    (defun autopairs-ret (arg)
      (interactive "P")
      (let (pair)
        (dolist (pair skeleton-pair-alist)
          (when (eq (char-after) (car (last pair)))
            (save-excursion (newline-and-indent))))
        (newline arg)
        (indent-according-to-mode)))

    (global-set-key (kbd "RET") 'autopairs-ret)

Why is this useful? Watch the little screencast above. The ##RET## key "opens" parenthetical expressions while editing; the ##)## key "closes" them. This is particularly convenient when writing Lisp code, as it facilitates line-wise editing without violating good code style.

== Filtering ==

By default, pairing will not be done if the following character is part of a word (##skeleton-pair-on-word##). To limit pairing further, the variable ##skeleton-pair-filter-function## points to a function which determines whether pairing is appropriate. If the function returns ##nil##, paired insertion ''is'' attempted; otherwise, paired insertion will ''not'' be performed.

For example,

    (setq skeleton-pair-filter-function
          '(lambda ()
             (cond
              ((eq last-command-char ?\")
               (or (looking-at   (regexp-quote (string last-command-char)))
                   (looking-back (regexp-quote (string last-command-char)))
                   (looking-back "[[:graph:]]")))
              (t
               (looking-at (regexp-quote (string last-command-char)))))))

The default clause above (##t##) means '##()##' will only be inserted if the cursor is not followed by '##(##' in the text. See the documentation of ##skeleton-pair-insert-maybe## (##C-h f skeleton-pair-insert-maybe##) for more information.

== Tips and tricks ==

To quickly "jump out of" a matched pair and to the end of the line, type '##C-e##'. See OpenNextLine to "jump" onto a new line.

== See also ==

Caio Marcelo's blog post [http://cmarcelo.wordpress.com/2008/04/26/a-little-emacs-experiment/ A little Emacs experiment] pieces together a similar system in a very educational manner.

The SkeletonMode page explores skeletons more broadly.

[ParEdit ParEdit] is a minor mode for Lisp languages, and provides enhanced [[sexp]] editing, navigating and manipulating. It does all of the above and more (but targets Lisp).

----
CategoryCode CategoryTemplates CategoryParentheses
