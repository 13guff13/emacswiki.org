Because of the nature of my work, I need to have a large number of buffers at my 
fingertips.  My buffer list becomes somewhat large, and I need to switch between 
them quickly while maintaining a train of thought.  A good buffer selection 
mechanism is crucial for productive work.  For several years I found that setting 
a key to the BS buffer list command (see BSBufferSelection) gave me most of what I needed.
I learned about sorting and subsetting the list through variables and hooks that BS 
provides, to locate the desired buffer quickly.

Eventually, though, using BS only is somewhat onerous.  To switch buffers, one 
needs to bring up the list of buffers, then find and pick the one desired.  
You can't look at the contents first before picking a buffer to type into.  
To look at one buffer before typing into another necessitates using BS twice.
Splitting windows helps with this, but I felt that I could devise something better.

In many situations there is usually a set of a few buffers that are frequently 
switched to; other buffers are useful to keep on hand, but they don't need to be 
looked at as frequently.  The similarity of this behavior to paging schemes in 
operating systems is obvious; the "locality of reference" principle, the
"working set" of pages in internal memory, etc.

Therefore, the new system would let one flip through the "working set" of buffers 
with a minimum of keystrokes but would also allow quick access to the whole 
buffer list.  Moreover, a minimal system without a lot of unneeded extras was 
desired; a simple system that can be understood and tweaked was deemed essential.

A few of the entries in the buffer switching category on the Emacs wiki were 
examined.  Two were found that looked close to what was desired:  [[iflipb]] and 
PinBar.  They each had features that were good, but neither was exactly what was 
sought.  A method that would keep the interruption to the normal work flow down 
to a minimum, use the absolute minimum of keystrokes, and be natural to use, were 
essential.

So it was decided that a new buffer switching solution would be created using 
ideas from iflipb and !PinBar as a starting point. This new system is called 
!ShortList (SL).



*Development notes:*

A separate mode is overkill, yet some key strokes need to captured and redefined 
to do the buffer switching.  All user interaction is through the 
minibuffer.  The core of SL uses the Emacs built-in function (read-key-sequence-vector) and the 
Emacs built-in variable unread-command-events.  (read-key-sequence-vector) captures a keystroke 
as a vector without executing the bound function.  In the SL-show function, the 
key is tested and if the keystroke is used for buffer switching it executes 
within the function.  If the key is not one used by the function, then it is 
"pushed back" (to the variable unread-command-events), to be by reread and 
executed in the current buffer's mode.

This scheme works beautifully; see the skeleton function below:
<pre>
(defun example ()
  "Example function showing the use of read-key-sequence-vector and unread-command-events."
  (interactive)
  (let (loop-fl ky kys) 
    (setq loop-fl t)
    (while loop-fl
      (setq loop-fl nil)
      (setq ky (read-key-sequence-vector nil))
      (setq kys (format "%S" ky))  ;; use for string comparisons of the vector
      (cond
       ((string-match "\\[7\\]" kys) ; allow ^G quitting of this function
        (setq quit-flag t)) ; system-wide built-in flag
       ((string-match "\\[left\\]" kys)  ; move left and right through list
        ;; do whatever you do when pressing the left arrow
        (setq loop-fl t))  ; repeat loop - stay in function
       ((string-match "\\[right\\]" kys)
        ;; do whatever you do when pressing the right arrow
        (setq loop-fl t))  ; repeat loop - stay in function
       ;;; etc. etc. - one cond entry for each key to capture
       (t    ; something else: push back the typed character, exit loop, and let the parent mode handle it
	(setq unread-command-events (append (listify-key-sequence ky) unread-command-events)))))))
</pre>

In the !ShortList system, SL-show is the function that does this.  
If you adopt this technique you will modify this function to define your own set 
of keys.

*Set up:*

The initial version of !ShortList has been posted.
After loading [[shortlist.el]], you will need to define three global keys:

(In !ShortList, the internal short list of buffers is called SL-list.)

1) The <SL add key>, bound to function (SL-add-key), to add the current buffer to 
SL-list. (I map M-a to (SL-add-key)).

2) The <SL delete key>, bound to (SL-del-key), to delete the current buffer from 
SL-list (I map M-d to (SL-del-key); the system also deletes buffers from the 
short list if the buffer is killed).

3) The <SL function key>, bound to (SL-show) (I use [kp-0]).


<b>!ShortList functionality:</b>

When the <SL function key> is pressed, SL-show is executed.  If SL-list is empty, 
this immediately brings up the BS list (my own preferred built-in buffer list 
function).  However, if the user has selected some buffers for SL-list, the 
behavior changes.

With a non-empty SL-list, when <SL function key> is pressed, a horizontal display 
of SL-list (called SL-line) appears in the minibuffer.  The current (visible) 
buffer is highlighted in SL-line.  To view another buffer, press either a number 
or left or right cursor keys.  As a new buffer is selected that buffer is 
immediately displayed, and SL-line is updated.  Whenever SL-line shows in the 
minibuffer the left and right arrow keys and number keys are intercepted to 
switch buffers.  If <SL function key> is pressed again, the full BS list of all 
buffers appears.  Pressing any other key while SL-line is shown will cause its 
function to be executed by the mode of the current buffer, and the SL-line 
disappears.  For instance, pressing a letter while the SL-line shows will cause 
(self-insert-command) to be executed in most modes.

Very often I want to switch to a buffer and reload the associated file using C-x 
C-v (find-alternate-file).  I can do this while the SL-line appears in the 
minibuffer (the C-x C-v keystrokes are "pushed back"), and (courtesy of some 
"around advice" to find-alternate-file) the newly loaded buffer remains on the 
SL-list.

Parent page : [[CategoryBufferSwitching|BufferSwitching]]
