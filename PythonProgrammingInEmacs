Information for creating a usable Python programming environment in emacs...

There are two implementations of a Python mode for Emacs:

# ProgrammingWithPythonDotEl

# ProgrammingWithPythonModeDotEl

I also found these useful:

* [http://www.enigmacurry.com/2008/05/09/emacs-as-a-powerful-python-ide/ Emacs as a powerful Python IDE]

* [http://www.enigmacurry.com/2009/01/21/autocompleteel-python-code-completion-in-emacs/ AutoComplete.el : Python Code Completion in Emacs]

* see [http://www.enigmacurry.com/2009/01/19/my-emacs-config-on-github/ My Emacs config on Github] for dotfiles

* [[RichardRiley]]s [http://richardriley.net/projects/emacs/dotprogramming#sec-1.5 python dotfiles]

* [http://gabrielelanaro.github.com/emacs-for-python/ another setup] based around python dev.

== Comment/Uncomment Region ==

If you have `transient-mark-mode' on, you can just use `comment-dwim': select a region and hit `M-;'. The DoWhatIMean means that it will comment or uncomment the region as appropriate. If you do not have `transient-mark-mode' on by default, you can hit C-SPC twice to activate it temporarily.

( doesn't python-mode.el offer `py-comment-region? --CH )

You can also use "rectangles" with comment/uncomment region (among other things that you can do with rectangles).  See RectangleCommands or "(emacs) Rectangles" in the Emacs manual.

== Search the python documentation in Emacs ==

Search the python online/offline documentations with convenience in Emacs

Github : http://github.com/tsgates/pylookup

Pylookup Mode : http://taesoo.org/Opensource/Pylookup

== Using Flymake with Python ===

= Using flymake with multiple lint, style and syntax checkers =

More than one code checking tool can be applied in flymake by using a
wrapper script that runs the desired tools and combines their output.
It has lots of issues, one being that flymake does not seem to show 
more than one error message per line of code, meaning that an error or
warning which is intentionally left unfixed can mask an error or
warning that would get more attention.

Additionally, the scripts that check python code are either
rather anemic, and don't notice too much (pychecker) or are 
aggressive, and warn about all sorts of things that they 
should not (pylint). pep8.py tends to be annoyingly aggressive
about whitespace.

There are several scripts around to do this, supporting various tools.
Each expects to find the code checking tools in your path (pep8.py,
pychecker, pylint, pyflakes, etc). Additionally this script attempts
to support virtual environments, but this is largely untested.

* The code [http://python.pastebin.com/f627691e0 here], [http://pastebin.ca/1797770 here] or [http://paste.uni.cc/20534 here] runs pylint + pychecker + pep8

* [http://bitbucket.org/tavisrudd/pylint_etc_wrapper.py/src/tip/pylint_etc_wrapper.py Here] is an extended, cleaned up and bug-fixed version of the script above by Tavis Rudd (not the original author)

* [http://bitbucket.org/jek/sandbox/src/tip/pycheckers pycheckers] runs pyflakes, pep8, pydo (configurable)

: I added this code to pastebins (didn't know which to prefer, so chose three) which should be better than dumping the code here. -- CH

= Using flymake with pylint =

[new]
Please note that pylint now comes with an executable "epylint" that is meant to be the interface to Emacs.
[new:Anonymous:2010-03-31 15:16 UTC]

The flymake mode in Emacs 22 does not understand Python, but it can be
made to work with [http://www.logilab.org/projects/pylint pylint].  To
do this, first you'll need to create a script somewhere along your
PATH called 'epylint'.  That script is [http://pastebin.ca/1797788 here]
: more pastebins needed? -- CH

It might appear that for some combinations of flymake, pylint and epylint
the above script might not work properly (it didn't for me). Debugging showed that
the regexp wasn't matching the output of pylint, ever, so the lines were being
printed from pylint verbatim, meaning that flymake was doing a "best effort"
match, and everything was coming up as an error, even minor warnings.

[http://pastebin.ca/1797794 Here] is an alternative version of the epylint script that works great for me.
It doesn't throw away all the R and C errors, just the most annoying ones. You can easily
modify it to include or exclude messages to your preference. I find it easier to have
the messages in the script rather than messing about with .pylintrc and the like.

(I've also got a version that inserts the overall code quality metric, as determined
by pylint, so you can see at a glance how close you are to pylint perfection; holler
here if you want to see it).
: that would be useful *holler* --CH
    
Once you test that this works on sample Python files, then add the
following to your InitFile to enable flymake checking of Python scripts
using pylint:

    (when (load "flymake" t)
      (defun flymake-pylint-init ()
        (let* ((temp-file (flymake-init-create-temp-buffer-copy
                           'flymake-create-temp-inplace))
           (local-file (file-relative-name
                        temp-file
                        (file-name-directory buffer-file-name))))
          (list "epylint" (list local-file))))
    
      (add-to-list 'flymake-allowed-file-name-masks
               '("\\.py\\'" flymake-pylint-init)))

Now if you turn on `flymake-mode' inside a Python file, you should see
lines with warnings highlighted in blue, and lines with errors
highlighted in red.  Just hover your mouse over either type of line
for a few seconds and you'll see a tooltip describing the
error/warning.  Plus, the modeline will show you two numbers, X/Y,
where X is the number of errors in your script, and Y is the total
number of warnings. -- JohnWiegley
: wait, this is for XEmacs, right?  -- CH

You can customise the way flymake highlights your Python by running
'M-x customize-face' on 'flymake-errline' or 'flymake-warnline'. For
example, you can remove the background highlight and make the face
be just a subtle coloured underline.

= Using flymake with pyflakes =

Found a desciption on how to use this pair at http://www.plope.com/Members/chrism/flymake-mode
I did a copy 'n paste for simplicity.

{{{
(when (load "flymake" t) 
  (defun flymake-pyflakes-init () 
     ; Make sure it's not a remote buffer or flymake would not work
     (when (not (subsetp (list (current-buffer)) (tramp-list-remote-buffers)))
      (let* ((temp-file (flymake-init-create-temp-buffer-copy 
                         'flymake-create-temp-inplace)) 
             (local-file (file-relative-name 
                          temp-file 
                          (file-name-directory buffer-file-name)))) 
        (list "pyflakes" (list local-file)))))
  (add-to-list 'flymake-allowed-file-name-masks 
               '("\\.py\\'" flymake-pyflakes-init))) 
}}}

There are some comments regarding using flymake-cursor to show the error in minibuffer [http://paste.lisp.org/display/60617,1/raw flymake-cursor.el] (the same idea is now available in [NxhtmlMode nXhtml] in the file <b>util/flymakemsg.el</b>).

* PyIndent

== Issues ==
This is a known bug (emacs 21.3): python-mode interferes with gud in such a way as to make the overlay arrow not work when debugging (even C source).

Disable auto-loading python-mode to get around this bug.
: This is one of the things fixed by the patch to python-mode.el, see ProgrammingWithPythonDotEl

== iPython Emacs 23 ==

RichardRiley

I found this which got me up and running with iPython integrated nicely into emacs 23. 

http://lists.ipython.scipy.org/pipermail/ipython-user/2008-September/005791.html

The important file, ipython.el, can be found here : http://ipython.scipy.org/dist/ipython.el

If you load it, ipython becomes the default python shell assuming the ipython executable is available.

my python integration is now like this:

<pre>
(setq load-path
      (append (list nil
                    "~/.emacs.d/python-mode-1.0/"
		    "~/.emacs.d/pymacs/"
		    "~/.emacs.d/ropemacs-0.6"
                    )
              load-path))

(require 'ipython)
(setq py-python-command-args '( "-colors" "Linux"))

(require 'python-mode)

(require 'pymacs)
(pymacs-load "ropemacs" "rope-")

;; (defadvice py-execute-buffer (around python-keep-focus activate)
;;   "Thie advice to make focus python source code after execute command `py-execute-buffer'."
;;   (let ((remember-window (selected-window))
;;         (remember-point (point)))
;;     ad-do-it
;;     (select-window remember-window)
;;     (goto-char remember-point)))

;; (defun rgr/python-execute()
;;   (interactive)
;;   (if mark-active
;;       (py-execute-string (buffer-substring-no-properties (region-beginning) (region-end)))
;;     (py-execute-buffer)))

;; (global-set-key (kbd "C-c C-e") 'rgr/python-execute)

(add-hook 'python-mode-hook
          '(lambda () (eldoc-mode 1)) t)

(provide 'python-programming)
</pre>

More iPython info here: http://ipython.scipy.org/moin/FrontPage

My own python files are here : http://richardriley.net/projects/emacs/dotprogramming#sec-1.4

Having got iPython working in emacs, I found the following "howto tutorial" videos to be superb for the beginner (me!) :

http://showmedo.com/videos/video?name=1000010&fromSeriesID=100

== Ipython completion ==

Ipython provide good completion support without extra dependencies.

However, to make it working in emacs, you will have to add this line to your .emacs:

<pre>
(setq ipython-completion-command-string "print(';'.join(__IP.Completer.all_completions('%s')))\n")
</pre>

The definition in ipython.el is wrong (or deprecated may be).

Note that Lisp:anything-ipython.el already fix this.

To have ido completion, simply comment and insert the following lines in ipython.el as shown below
<pre>
;; (with-output-to-temp-buffer "*IPython Completions*"
;;   (display-completion-list (all-completions pattern completion-table)))
(let* ((dotposition (- (length pattern ) (length (first (last (split-string pattern "[\.]")) ) ) ))
       (ido-ipython-selection  (ido-completing-read (concat  "Choose a completion: " pattern)
						    (mapcar (lambda (x) (substring x dotposition))
							    (all-completions pattern completion-table)))))
  (delete-char (- dotposition (length pattern)))
  (insert ido-ipython-selection))
</pre>

To have an even better completion, you should install also rlcompleter2.

http://codespeak.net/rlcompleter2/

Lisp:anything-ipython.el provide an anything interface for ipython completion in your python buffer.

You will find all instructions to install Lisp:anything-ipython.el in the headers of file.

You will need of course a complete Anything install, look how to install Anything at

http://www.emacswiki.org/cgi-bin/emacs/Anything

Screenshot of anything-ipython in action:

http://farm4.static.flickr.com/3459/3760695525_887356961c.jpg

== auto-complete.el support in ipython shell buffers == 
http://bitbucket.org/tavisrudd/emacs.d/src/tip/dss-completion.el

== Ipython debugging/pdbtrack ==

I made the following changes to python-mode.el to make debugging work again with current IPython (0.9.1):

[...]

 ;; pdbtrack constants
 (defconst py-pdbtrack-stack-entry-regexp
  "^> \\(.*\\)(\\([0-9]+\\))\\([?a-zA-Z0-9_<>]+\\)()"; this is new
 ;  "^> \\([^(]+\\)(\\([0-9]+\\))\\([?a-zA-Z0-9_]+\\)()"
 ;  "^> \\(.*\\)(\\([0-9]+\\))\\([?a-zA-Z0-9_]+\\)()"
   "Regular expression pdbtrack uses to find a stack trace entry.")
 
 ;(defconst py-pdbtrack-input-prompt "\n[(<]*[Pp]db[>)]+ "
 (defconst py-pdbtrack-input-prompt "\n[(<]*[Ii]?[Pp]db[>)]+ "; this is new
   "Regular expression pdbtrack uses to recognize a pdb prompt.")

[...]

            (py-pdbtrack-overlay-arrow nil)

          (setq block (ansi-color-filter-apply block)) ; this is new
          (setq target (py-pdbtrack-get-source-buffer block))

[...]

Now when I debug in the IPython console (using %run -d, or %pdb on, etc.) pdbtrack makes sure to show me the current source code and corresponding line. Note that these changes may break debugging in a standard python-shell, I have not tested this.

----
ProgrammingModes
