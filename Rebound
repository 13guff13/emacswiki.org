Emacs conveniently allows one to work on different parts of the same buffer at the same time, but the rules governing buffer display are, for some people's editing habits, less than ideal.  Suppose for example that one is editing two parts of buffer <i>buf</i> in windows <i>win-1</i> and <i>win-2</i>, switches briefly to another buffer in <i>win-2</i>, then returns to editing <i>buf</i> in <i>win-2</i>.  This latter window will now display the same part of <i>buf</i> as <i>win-1</i>, rather than the portion that one was just recently editing in it.  The package <tt>[[rebound.el]]</tt> (by [[AlpAker]]) creates persistent values of window-point and window-start, so that in cases like that just described <i>win-2</i> will return to its previous position in <i>buf</i>.

In some cases, as when another Lisp program wants to move point in a buffer and then display that buffer in a window, it makes sense for Rebound not to position point in that window.  (For example, when looking up a function definition via `describe-function', point is moved to the function definition before the library that defines the function is displayed; we then don't want to move point away from the definition when the library is displayed.)  The package is reasonably intelligent in identifying situations in which it should defer to other Lisp programs.  It also provides a hook so that the user can define other types of exception.

----
[new]
Do you know about winpoint.el? How does rebound.el compare to winpoint.el? -- LennartBorgman

[new:AlpAker:2011-03-10 21:29 UTC]

I was unaware of Winpoint until now, but  the functionality appears to be very similar.  The differences I see at first glance: 

* The internal mechanisms are different.  Winpoint uses post-command-hook and window-configuration-change-hook to record the most recent values of point, while Rebound advises functions such as switch-to-buffer, etc.  I haven't closely studied the Winpoint code, but there will likely be edge cases in which it fails to record the most up-to-date value of point (an early version of Rebound used the same mechanism as Winpoint and I ran into this problem).  These cases arise relatively infrequently, however.  

* Winpoint doesn't appear to make any attempt to avoid conflicts with other Lisp programs, as described in the second paragraph of the Rebound description above.  (It allows you to specify, on an individual basis, buffers whose point values shouldn't be restored, but when, e.g., looking up function definitions in Elisp libraries, one needs dynamic identification of which buffers shouldn't have point restored.)   It wouldn't be hard to add this ability to Winpoint, however. 

* Rebound allows the user more flexibility in specifying exceptions.  Winpoint, as mentioned, allows you only to specify names of buffers to ignore; Rebound lets you use any test that is a function of the buffer and the window the buffer is to be displayed in.  (Thus, for example, you can exempt all buffers whose name matches a particular regexp, or all buffers with a particular major mode.)  Again, it wouldn't be hard to hack Winpoint to add this ability.  

* Winpoint appears only to restore point, not window-start.  Whether that matters to a user is purely a matter of taste, I suppose. 

In sum, the differences aren't great, although I think Rebound is, as described above, more robust and flexible.  I should note, though, that Rebound depends on advising primitives, which some think is bad style in Elisp; that might be a reason to be prefer Winpoint.   --AA

[new]
The preferred way to do things like this is to use hooks, since that is more stable and is less likely to interfere with other programs. I think the functionality in winpoint/rebound is very useful and it would be good to have this in Emacs itself in my opinion. Perhaps you and the winpoint author want to take this up on Emacs devel list? -- LennartBorgman

[new:AlpAker:2011-03-11 23:18 UTC]
I'd like to see something like this included in Emacs.  Sadly, every feature request I've made to the developers in the past has been ignored.  But perhaps joining forces with the Winpoint author will make a response more likely.   

I agree, of course, that using hooks is preferable to advising primitives.  However, I don't think that hooks are sufficient here; we simply don't have the right hooks.  As I mentioned, when I first wrote Rebound I used the same technique as Winpoint, but found that it didn't work robustly.  For example, if a command moves point then changes which buffer is displayed in a window, Winpoint will fail to record the new value of point.  What's needed is a hook that's called just before the buffer displayed in a window changes (something like a pre-window-configuration-change-hook); unfortunately, no such hook exists.

Even better would be to record independent window-point values at the level of C code.  In fact, from my limited perusal of the C code, something close to the necessary data structures seem to be already in place, so it wouldn't be a very hard change to implement.   -AA

----


[new:TN:2011-03-10 08:41 UTC]
Hello AlpAker,

what is the advantage of Rebound over clone-indirect-buffer?
Till now I always use clone-indirect-buffer for that purpose but maybe I switch to Rebound if there are some strong reasons for that.

Best regards,
TN

[new:AlpAker:2011-03-10 08:46 UTC]

The differences between the two methods aren't great (I used to use indirect buffers for this purpose as well).   In general, I find using Rebound to be faster and more intuitive than using indirect buffers.  (But it's not surprising that its behavior matches my intuition, since it was written to behave in a way I find intuitive.)  Here are four ways in which I find using something like Rebound to be smoother than using indirect buffers:

* With Rebound, I simply select the window and the buffer I want to edit a new part of.  With indirect buffers, I need to pause for the separate call to clone-indirect-buffer.  In addition, clone-indirect-buffer uses pop-to-buffer to display the new indirect buffer, and the window pop-to-buffer selects is frequently not  the one I want to use, which requires another series of commands to restore the arrangement of buffers and windows I want (including, sometimes, moving point back to where I want it in the buffer that pop-to-buffer displaces).  

* Having multiple indirect buffers makes the buffer menu more crowded, which (for me) slows down navigation between buffers.  

* When I'm done using an indirect buffer, I have to remember to kill it (so as to, e.g., unclog the buffer menu).  (Additionally, I sometimes accidentally kill the base buffer when I intend only to kill one of the indirect copies, which is very annoying.)

* With Rebound, I can conceptualize the parts of the buffer I'm editing in terms of screen location.  For example, I can think, "left window is associated with the top of the buffer, right window with the middle."    Using indirect buffers requires me to spend some thought remembering which version of the buffer is associated with which part of the buffer when switching back and forth among files.   (For one indirect buffer this is a trivial problem, but occasionally I need multiple indirect copies of the same buffer, in which case it becomes non-trivial.)

For me, then, using indirect buffers interrupts the flow of editing.  That's the primary reason I wrote Rebound.  There are some other issues, however: 

* Indirect buffers do not have file names associated with them; only the base buffer does.  Lisp functions that need to know the name of the file associated with the buffer can thus break down when used with indirect buffers.  For example,  I  often work on LaTeX files, and a number of RefTeX functions do not work properly on indirect buffers.  (It <i>shouldn't</i> be hard to hack RefTeX to accomodate indirect buffers, but it would require redefinition of several RefTeX functions; the advice mechanism isn't sufficient for this. And, unfortunately,  RefTeX is not as modular as it should be, so rewriting parts of it can be an annoying task.)

* Any package using overlays works differently in the two cases.  With indirect buffers, the overlays in the base buffer and those in each indirect buffer are distinct.  With Rebound, the buffer is the same, so the overlays are the same.  Thus, with indirect buffers, folding in outline mode, in AucTeX, etc., works on each version independently.  With Rebound, each "version" of the buffer is controlled by outlining, etc. in the same way.  What one makes of this difference is very much a matter of personal taste.  Similarly, with indirect buffers mode changes affect only one version of the buffer.  This can be annoying when, e.g., toggling LaTeX-math-mode on and off.

Those are the differences that occur to me immediately; there are probably others.  As I said, they're not huge, and which method is preferable for a particular person depends on their tastes and editing style.  For me, the first group of issues especially are significant as regards preserving an uninterrupted train of thought during editing.  I'd imagine that many others don't find such factors to be a problem at all.  

You might also want to look at [[winpoint.el]], which is very similar to Rebound and which LennartBorgman brought to my attention above. --AA  

----
CategoryBufferSwitching
