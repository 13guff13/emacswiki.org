I use GNU Emacs as well as other programs, such as Microsoft Word, Excel and Lotus Notes. So I used to copy and paste some contents between them.

It's pretty boring to copy and paste a large amount of times.
Selecting accurately is what is the most time-consuming.
 So I decided to leverage GNU Emacs to do it for me.

The simplest way to do this is just to copy without selection. Put
your point at the word, then your word will be copied directly into
the kill-ring. Same thing happens for lines and paragraphs.
I have devised a few functions that can be found below.

But first let's see what we can do with some basic shortcuts.

== Selecting words or sexps without moving the cursor ==

You can select word or sexp after point and put it in the kill-ring by typing:

         C-M-SPC M-w

This does not move the cursor. 
If you want to select the next two words after point, 
just type <code>C-M-SPC C-M-SPC M-w</code>.
Killing next word or sexp can be done with <code>C-M-SPC C-w</code>, or better with <code>C-M-k</code>.

=Copy Word=

Put these code into your lisp file and a global key binding into your .emacs file. Then just put your point at the word and  press "**Ctrl-c w**", the word at your point will be copied into the kill-ring. 

     (defun copy-word (&optional arg)
      "Copy words at point into kill-ring"
       (interactive "P")
       (let ((beg (progn (if (looking-back "[a-zA-Z0-9]" 1) (backward-word 1)) (point))) 
     	(end (progn (forward-word arg) (point))))
         (copy-region-as-kill beg end))
     )


Key binding

     (global-set-key (kbd "C-c w")         (quote copy-word))

=Copy Line=

Put these code into your lisp file and a global key binding into your .emacs file. Then just put your point at the line and  press "**Ctrl-c l**", the whole line at your point will be copied into the kill-ring. 

     (defun copy-line (&optional arg)
      "Save current line into Kill-Ring without mark the line "
       (interactive "P")
       (let ((beg (line-beginning-position)) 
     	(end (line-end-position arg)))
         (copy-region-as-kill beg end))
     )

Key binding

      (global-set-key (kbd "C-c l")         (quote copy-line))

[new]
*Tip:* SlickCopy copies the current line when the region is not active. Thus, ##C-a M-w C-y C-y## ... duplicates the current line (similar to vi's '##yyp##'), while ##C-w## deletes it (‘##dd##’). When the region /is/ active, ##M-w## and ##C-w## act as usual. :)

=Copy Paragraph=

Put these code into your lisp file and a global key binding into your .emacs file. Then just put your point at the paragraph and press "**Ctrl-c p**", the whole paragraph at your point will be copied into the kill-ring. 
      
     (defun copy-paragraph (&optional arg)
      "Copy paragraphes at point"
       (interactive "P")
       (let ((beg (progn (backward-paragraph 1) (point))) 
     	(end (progn (forward-paragraph arg) (point))))
         (copy-region-as-kill beg end))
     )


Key binding

      (global-set-key (kbd "C-c p")         (quote copy-paragraph))

=Copy String=

Put these code into your lisp file and a global key binding into your .emacs file. Then just put your point at the word and  press "**Ctrl-c s**", the text string at your point will be copied into the kill-ring. 


      (defun copy-string (&optional arg)
       "Copy a sequence of string into kill-ring"
        (interactive)
        (setq onPoint (point))
        (let ( 
     	 ( beg 	(progn (re-search-backward "[\t ]" (line-beginning-position) 3 1) 
     			  (if (looking-at "[\t ]") (+ (point) 1) (point) ) )
     		)
               ( end  (progn  (goto-char onPoint) (re-search-forward "[\t ]" (line-end-position) 3 1)
     			  (if (looking-back "[\t ]") (- (point) 1) (point) ) )
     		 ))
        (copy-region-as-kill beg end)
      )
      )

Key binding

      (global-set-key (kbd "C-c s")         (quote copy-string))

That's all. 

----
==Comment==
Have you see Lisp:thing-edit.el ?  -- AndyStewart

----
----
==Comment==
-- David Young

Thanks for your advise. It's cool. I evaluated thing-edit.el. Yeah I actually modified some of my functions to leverage the thingatpt.el. I love to leverage build-in functions as much as possible than to write my own ones. But anyway, it does not give me what copy-string could do fo me. 

I used to do my daily work in shell mode. So I used to need some information to be copied to the command line. For example something like this, when I issue *runmqsc QMCOD* in the command line, I would get a screen like this:

{{{
-bash-3.2# runmqsc QMCOD
5724-H72 (C) Copyright IBM Corp. 1994, 2009.  ALL RIGHTS RESERVED.
Starting MQSC for queue manager QMCOD.


DIS CHL(T*)
     1 : DIS CHL(T*)
AMQ8414: Display Channel details.
   CHANNEL(TO.QMCM.4.FTECA)                CHLTYPE(CLUSSDR)
AMQ8414: Display Channel details.
   CHANNEL(TO.QMCOD.4.FTECA)               CHLTYPE(CLUSRCVR)

START 
}}}

And now I would need a command like <b>START CHANNEL(TO.QMCOD.4.FTECA)</b> by copy a string like <b>CHANNEL(TO.QMCOD.4.FTECA)</b> and paste it after *START* 

Or I would need a command like <b>ALTER  CHANNEL(TO.QMCOD.4.FTECA) CHLTYPE(CLUSRCVR)</b> by copy above string as well as ' *CHLTYPE(CLUSRCVR)* and paste them after *ALTER* in the command line.

Both <b>thing-copy-sexp</b> and <b>thing-copy-symbol</b> do not work in this way. Maybe I am not actually understand how thing-copy-sexp works. I don't find enough document for it in thingatpt.el. 

And since copy & paste are used pairs, I extended my copy-xxx stuffs to copy-xxx-to-mark like this:

{{{

(defun copy-symbol-to-mark (&optional arg)
   "This is a re-write of copy-string-to-mark, using thingatpt.el 
But it does not actually do the same as what copy-string does"
   (interactive "P")
   (kill-ring-save (beginning-of-thing 'symbol) (end-of-thing 'symbol))
   (if (not arg) 
       (if (string= "shell-mode" major-mode)  
	   (progn (comint-next-prompt 25535) (yank))
	   (progn (goto-char (mark)) (yank) )))
)


;; (defun copy-string-to-mark (&optional arg)
;;  "Copy a sequence of string into kill-ring and then paste to the mark point"
;;   (interactive "P")
;;   (let (
;;	 (onPoint (point))
;;	 )
;;     (let ( 
;;	 
;;	 ( beg 	(progn (re-search-backward "[\t ]" (line-beginning-position) 3 1) 
;;			  (if (looking-at "[\t ]") (+ (point) 1) (point) ) )
;;		)
;;          ( end  (progn  (goto-char onPoint) (re-search-forward "[\t ]" (line-end-position) 3 1)
;;			  (if (looking-back "[\t ]") (- (point) 1) (point) ) )
;;		 )
;;	  )
;;       (copy-region-as-kill beg end)
;;       (message "%s" major-mode)
;;       (if (string= "shell-mode" major-mode)  
;;	   (progn (comint-next-prompt 25535) (yank))
;;	 ;; unless arg == 0, paste content to mark, else hold in kill ring
;;	   (unless (> (or arg 0) 0) (progn (goto-char (mark)) (yank) )))
;;
;;       )
;;     )
;; )

}}}
----

----
==Comment -- thing-copy-string ==

-- David Young

By reading the code in thingatpt.el, I extended it to provide a 'thing-copy-string' function. It is a re-write of 'thing-copy-email'. 
However, this is just a dirty fix. It is not practiced in my real work. I will try to practice and refine the regexp as time goes on.

{{{


(defvar thing-at-point-string-regexp
   "[^ (][-+_.~a-zA-Z0-9@=\*\&(){}][-+_.~a-zA-Z0-9@=\*\&(){}]+"
  "A regular expression match a string, maybe exclude all kinds of brackets")

(put 'string 'bounds-of-thing-at-point
     (lambda ()
       (let ((thing (thing-at-point-looking-at thing-at-point-string-regexp)))
         (if thing
             (let ((beginning (match-beginning 0))
                   (end (match-end 0)))
               (cons beginning end))))))

(put 'string 'thing-at-point
     (lambda ()
       (let ((boundary-pair (bounds-of-thing-at-point 'string)))
         (if boundary-pair
             (buffer-substring-no-properties
              (car boundary-pair) (cdr boundary-pair))))))

(defun thing-copy-string ()
  "Try to get string"
  (interactive)
  (thing-edit 'string)
)

}}}

CategoryRegion  CategoryEditing
