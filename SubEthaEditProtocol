== Meta Information ==

The purpose of this page is to describe the protocol used by the
SubEthaEdit collaborative editor. This information can then be used to
interface other editors with SubEthaEdit, for example Emacs.

For projects working on interfacing Emacs and SubEthaEdit see:
* SubEthaEmacs
* [[Rudel]]

=== Reverse Engineering Requirements ===

Before getting on to the meat of this page: Please do /not/ add any
information of /questionable/ source.  This means that information
gleaned from examination of the binary you got from
http://codingmonkeys.de is right out, including simply running strings
on it.  What's in is information gleaned by any of the methods
described in http://samba.org/ftp/tridge/misc/french_cafe.txt --
specifically, anything that only involves running the program, and
examining the information it sends across the wire.  While it is my
belief that reverse engineering for the purpose of interoperability is
a protected right, it's not 100% clear, esp as you go from
jurisdiction to jurisdiction.  I figure that if Andrew Tridgel feels
OK saying in open court that he did these things against Microsoft,
we're probably safe from the presumably less litigious codingmonkeys.

== Introduction ==

The SubEthaEdit protocol has a fair number of parts.

You've probably heard that it uses Bonjour (AKA
<nowiki>ZeroConf</nowiki>, Rendezvous).  While this is true, its use
of Bonjour isn't interesting; it's only useful when you have multiple
users on the same subnet.  In any case, it simply advertises
<nowiki><username>@<computername>._see</nowiki>, with no additional
data that I can see.  I have no particular interest in supporting this
part of the protocol: sessions will be initiated by giving the
hostname or IP and optionally port.  (The default port is 6942, which
codingmonkeys says can be remembered because 6*9=42 -- it's a
[http://en.wikipedia.org/wiki/Hitchikers_guide Hitchhiker's Guide to
the Galaxy] reference.)

== The BEEP Protocol ==

The actual conversations between SEE client and server are done under
the BlocksExtensibleExchangeProtocol (RFC 3080 and RFC 3081), which is
a generic, channel multiplexed, transport protocol that uses uses XML
and MIME.  (Very simple versions of both -- the only MIME header used
is Content-Type.)

Messages in the special channel 0 are fully specified in RFC 3080, all
other channels are freely usable by application protocols. Each
channel has an associated profile, identified by an URI, that defines
the protocol for messages exchanged on that channel.

The authors of SEE decided to ignore the recommendation of the RFC
authors to use MIME. Instead, the payload consists of a three-letter
major command code, mostly followed by a three-letter minor command
code, often followed by bencoded data.

[new]
Note by a SEE author: we did this for the obvious reason that: a)
having our own profiles means that doesn't worry anybody else and b)
since we use a lot of very small messages, the redundant MIME headers
would just add up and use unnecessary bandwidth).

[new]
Messages generally look similar to the following example:
{{{
MSG 1 0 . 0 97
GRTd3:url27:see://codingmonkeys.de:67423:uid36:770da15c-0cb0-10da-a8ba-4a773bbddd094:vers3:200e
END
}}}
Here, the bencoded data starts immediately after 'GRT'.
Bencoding is the data format used by bittorent; it is specified (very
briefly) at http://www.bittorrent.com/protocol.html.  The dialect that
SEE uses has a small extension: Strings may have a . (ASCII 0x2e)
after the length instead of a ':'.  These dot-strings are used for
user-identifiers, and other such things that are not human-readable
strings, but rather a bunch of random bytes.  I suspect the correct
interpretation is that '.' strings contain binary data without
semantics, whereas ':' strings are always utf-8.  (Note that the
length for strings of both types is in /bytes/, not logical
characters.)

== BEEP Profiles used by SubEthaEdit ==

As soon as an initiating SEE instance has an open socket, it sends
{{{
<greeting>
  <profile uri="http://www.codingmonkeys.de/BEEP/SubEthaEditHandshake"/>
  <profile uri="http://www.codingmonkeys.de/BEEP/TCMMMStatus"/>
  <profile uri="http://www.codingmonkeys.de/BEEP/SubEthaEditSession"/>
</greeting>
}}}
on BEEP channel 0, advertising support for three BEEP profiles:
* <nowiki>http://www.codingmonkeys.de/BEEP/SubEthaEditHandshake</nowiki>
* <nowiki>http://www.codingmonkeys.de/BEEP/TCMMMStatus</nowiki>
* <nowiki>http://www.codingmonkeys.de/BEEP/SubEthaEditSession</nowiki>

The listening instance replies with an almost identical message, the
difference being one additional profile:
* <nowiki>http://iana.org/beep/TLS</nowiki>

Upon receiving this message from the listening end, the initiating
client can request a <nowiki>SubEthaEditHandshake</nowiki> channel
from the server:
{{{
MSG 0 1 . 301 136
Content-Type: application/beep+xml

<start number="1"><profile uri="http://www.codingmonkeys.de/BEEP/SubEthaEditHandshake"/></start>
END
}}}
or request TLS encryption:
{{{
MSG 0 1 . 263 135
Content-Type: application/beep+xml

<start number='1'><profile uri='http://iana.org/beep/TLS'><![CDATA[<ready />]]></profile></start>END
}}}

=== The Handshake Profile (SubEthaEditHandshake) ===

; ##GRT## Message: This is sent immediately upon initiation of the
  channel.
  The listening peer answers with a ##GRT## message that is
  identically structured but can have different dictionary values.
  Takes a dictionary with the following values:
** url => URL of the remote end of the connection -- sometimes has a
   <nowiki>see://</nowiki> protocol on it, sometimes does not.  Always
   seems to include the port. Example: ##see://codingmonkeys.de:6942##.
   In the response from the listening peer, the semantics are reversed: it
   is the IP-address and port of the initiating peer. Example:
   ##212.204.60.78:65164##
** uid => UUID of... something.  Undetermined if this is the client
   install, the user, or what.  Normal hex, dash-separated format,
   without curly braces.  (As specified in RFC 4122 or
   http://www.ietf.org/internet-drafts/draft-mealling-uuid-urn-05.txt.)
   Example: ##c26bff50-3f16-b1f6-e60c-8858649bdc56##
** vers => the version of the protocol in use?  Only known value is '200'.
** uag => only present in the listening peer's response (?). Seems to
   describe the software version. Example: ##SubEthaEdit/3.5.1 (3263)##
; ##ACK## Message: Acknowledges a message from the other end of the
  connection.
  Possibly the simplest payload, it takes no extra data of any sort.
  FIXME: what packet is this acking? This seems to be send by the
  initiating peer after it received the 'GRT' response from the
  listening peer.
; empty Message: It seems like the listening peer replies to the
  ##ACK## message of the initiating peer by sending a BEEP message that
  has no payload. This message seems to conclude the handshake.

...more later.

=== The Status Profile (TCMMMStatus) ===

A TCMMMStatus channel is created by both sides of the connection. The
listening peer requests a TCMMMStatus channel after receiving the
'ACK' message on the handshake channel.

* USRCHG: User Change (?) - Gives a short description of a user, a dictionary with the following vals:
** cnt => An integer, presumably some sort of count (of what?)
** name => A user name.
** uID => A 16 byte id string unique for the user (presumably).

* STAVIS: Status Visible (?) - Not sure of the purpose of this one, no known content.

* USRREQ: User Request (?) - Only see with an empty list as content, so far, maybe its supposed to be a list of users that the peer should send full information for?

* USRFUL: User Full (?) - A longer user description, including:
** cnt => An integer, counting something.. ?
** hue => As an integer, color of something, probably highlight color of this user's text
** uID => Users unique ID, same as in USRCHG
** name => Users name, same as in USRCHG
** mail => Users email address, probably taken from Address Book data
** PNG => The users icon, as a PNG file (contains the actual picture data as a byte string), probably taken from NetInfo data
** AIM => Users AIM screenname, probably taken from Address Book data

* DOCANN: Document Announce (?) - Announces each document that the peer has to offer:
** name => Name of the document
** sID => ID of something
** hID => Yet another ID of something
** acc => ??

=== The Session Profile (SubEthaEditSession) ====

Started by the client (either side?) to join a particular document.

* JONJON: Join request - sent by the client
** UserNotification => a dictionary containing:
*** cnt => An integer, counting ?
*** name => Users name
*** uID => Users unique ID
** SessionID => UUID denoting the session, see GRT

* JONACK: Join Acknowledge - Empty acknowledge command

* SESINF: Session Information - Information about the session, from the document owning peer
** ContentLength => Integer - doc length?
** Participants => a dictionary containing:
*** ReadWrite => a list of dictionaries containing:
**** User => a dictionary containing:
***** cnt => integer, counter (?)
***** name => users name
***** uID => Users unique id
**** SessionProperties => an empty dictionary ?
**** User => ..
** Contributors => a list of dictionaries of:
*** cnt
*** name
*** uID
** DocumentSessionInformation => a dictionary containing:
*** UseTabs => Integer (0/1)
*** DocumentMode => String "SEEMode.Base"
*** LineEnding => Integer 1
*** TabWidth => Integer 4
*** WrapLines => Integer 1
*** WrapMode => Integer 1

* USRREQ: User Request - empty list

* SESCON: Session Connection (?) - Original document status ?
** TextStorage => dictionary containing:
*** String => String containin document content
*** Encoding => Integer 30
** Attributes => dictionary containing:
*** ChangedByUserID => list of dictionary containing:
**** val => UUID
**** loc => Integer 0
**** len => Integer 1508
** WrittenByUserID => list of dictionary containing:
*** val => UUID
*** loc => Integer
*** len => Integer

* DOCMSG: Document Message -
** op => dictionary containing:
*** ot => "sel" | "txt" | "nop"
*** len => Integer (not present with ot => "nop")
*** uid => User unique id
*** loc => Integer (not present with ot => "nop") - cursor location
*** str => String that was added (only present by ot => "txt")
** #C => Integer
** #S => Integer

----

CategoryInterface
