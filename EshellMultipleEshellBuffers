It is sometimes annoying to use multiple shells from within emacs. One must create a shell, rename it, create another, etc.

== Native Eshell ==

Eshell itself can open a specific new buffer when invoked as (eshell 'N) where N is a positive integer. When invoked as (eshell 'Z) where Z is not a positive integer, it will open the next sequential free shell number.

== Shell-switcher ==

[https://github.com/DamienCassou/shell-switcher shell-switcher] is an emacs minor mode to easily switch between shell buffers (like with alt+tab). It works with eshell and any other shell.

Check the [http://www.youtube.com/watch?v=jNSrrQwcCr4 screencast]!


== Multi-eshell ==

[http://cims.nyu.edu/~stucchio/software/elisp/multi-eshell.el.html multi-eshell.el] exists. It maintains a ring of shell buffers, and has 3 useful functions:

multi-eshell -- Creates a NEW shell and switches to it, even if one already exists.

multi-eshell-switch -- If not in a shell buffer, return to the last EXISTING
                       shell buffer. Otherwise, switch to the next buffer in
                       the shell ring.

multi-eshell-go-back -- Switch to the previous buffer in the shell ring.

Q: What advantages does this provide over using M-x eshell-new along with various buffer switching techniques?

A: Convenience, nothing more. One-button cycling through eshell buffers can be faster than C-x b *eshell*<2> (especially if you don't remember which *eshell*<?> you want to switch to). Also, is eshell-new part of emacs? It doesn't appear to be in 22.1.50 (of Carbon emacs).

[new:Anonymous:2012-04-13 12:09 UTC]
multi-eshell-function calls multi-eshell-shell-function that may change default-directory (the shell command does that). Thus, when wanting to start a new shell with multi-eshell-shell-function=shell, the new shell will be started in the same directory than the previous shell while it would make more sense to launch it in the default-directory where the multi-eshell was launched. This should fix this issues :

{{{
--- b/multi-eshell.el
+++ a/multi-eshell.el
@@ -45,7 +45,16 @@
   :type 'string
   :group 'multi-eshell)

-(defun multi-eshell-function () "This function opens the appropriate shell." (eval multi-eshell-shell-function) )
+(defun multi-eshell-function ()
+  "This function opens the appropriate shell and restores the default-directory
+after"
+  (let(
+	   (cur_dir default-directory)
+	   )
+   (eval multi-eshell-shell-function)
+   (setq default-directory cur_dir)
+   )
+)
 ;;;(defvar multi-eshell-function `(shell) ) ;;; Defines the shell. ('shell) or ('eshell)
 ;(defvar multi-eshell-name "*eshell*") ;;; Name of default shell or eshell buffer
}}}

== Multi-Esh (not to be confused with multi-eshell) ==
This one is a lot more basic than shell-switcher and multi-eshell, but I didn't like the way they work.  It's kind of a stripped down cross between multi-term.el and multi-eshell.el
{{{
;;;; Implements an eshell multiplexer
;;;; Author: Qudit314159
;;;; Not to be confused with multi-eshell.el

(defvar multi-esh-last-buffer nil
  "The buffer to go back to in `multi-esh-next' and `multi-esh-next' if the current buffer is not a terminal buffer.")

(defvar multi-esh-buffers nil)

(defun multi-esh-filter-buffers ()
  (setq multi-esh-buffers (filter 'buffer-live-p multi-esh-buffers)))

(defun multi-esh ()
  "Create a new term buffer."
  (interactive)
  (eshell t)
  (setq multi-esh-buffers (nconc multi-esh-buffers (list (current-buffer))))
  (setq multi-esh-last-buffer (current-buffer)))

(defun multi-esh-switch (offset)
  (multi-esh-filter-buffers)
  (let* ((k (position (current-buffer) multi-esh-buffers))
         (n (length multi-esh-buffers))
         (buf (nth (mod (+ k offset) n) multi-esh-buffers)))
    (switch-to-buffer buf)))

(defun multi-esh-next (&optional offset)
  "Go to the next eshell buffer if in an eshell or the last
eshell buffer otherwise.  If OFFSET is `non-nil', will goto the
next term buffer with OFFSET."
  (interactive "P")
  (if (null offset)
      (setq offset 1))
  (cond
   ((and (not (eq major-mode 'eshell-mode))
         (buffer-live-p multi-esh-last-buffer))
    (switch-to-buffer multi-esh-last-buffer))
   (t
    (multi-esh-switch offset))))

(defun multi-esh-previous (&optional offset)
  "Go to the next eshell buffer if in an eshell or the last
eshell buffer otherwise.  If OFFSET is `non-nil', will goto the
previous eshell buffer with OFFSET."
  (interactive "P")
  (if (null offset)
      (setq offset 1))
  (cond
   ((and (not (eq major-mode 'eshell-mode))
         (buffer-live-p multi-esh-last-buffer))
    (switch-to-buffer multi-esh-last-buffer))
   (t
    (multi-esh-switch (- offset)))))

(dolist (fun '(set-buffer select-window select-frame))
  (eval `(defadvice ,fun (after set-last-multi-esh-buffer activate)
           "If eshell is running in the buffer switched to, remember that it was the last eshell buffer."
           (when (eq major-mode 'eshell-mode)
             (setq multi-esh-last-buffer (current-buffer))))))

(provide 'multi-esh)
}}}
