Skeleton is very powerful special-purpose mini-language implemented in EmacsLisp. The definition of a skeleton looks like a mixture of an EmacsLisp function and line noise. Nevertheless, they are very powerful. Typically, skeletons are used in conjunction with AbbrevMode for automatic insertion of customized templates and such. GnuEmacs comes with an "Autotype" InfoMode manual (`C-h i d m Autotype RET') which explains skeletons. You may also read the documentation of ##skeleton-insert## for more info.

== Introduction to Skeleton Mode ==

TomBreton wrote a nice recipe for skeletons: RecipeForSkeletonMode.

== Simple example ==

Here is an example that sets up a general LaTeX letter. Most of the elements after the DocString are plain strings. These are inserted as is. The first string is the !DocString. The second string is the ''prompt string'', with which the minibuffer prompts for a value whenever the ##str## symbol occurs in the skeleton, using the entered value in place of the symbol. The construct ##str | " *** Empfänger *** "## means that "##*** Empfänger ***##" will be used as the default value if nothing was entered at the prompt. Finally, the ##_## symbol specifies the "wrap position", i.e., where the point will end up when the skeleton has been inserted. If any text is selected beforehand, the skeleton will wrap around it.

Place the code below in <tt>[InitFile .emacs]</tt>:

    (define-skeleton latex-skeleton
      "Inserts a Latex letter skeleton into current buffer.
    This only makes sense for empty buffers."
      "Empfänger: "
      "\\documentclass[a4paper]{letter}\n"
      "\\usepackage{german}\n"
      "\\usepackage[latin1]{inputenc}\n"
      "\\name{A. Schröder}\n"
      "\\address{Alexander Schröder \\\\ Langstrasse 104 \\\\ 8004 Zürich}\n"
      "\\begin{document}\n"
      "\\begin{letter}{" str | " *** Empfänger *** " "}\n"
      "\\opening{" _ "}\n\n"
      "\\closing{Mit freundlichen Grüssen,}\n"
      "\\end{letter}\n"
      "\\end{document}\n")

Then you can, for example, bind it to a key with:

    (global-set-key "\C-cl" 'latex-skeleton)

Very simple, right?

Of course, the scheme is infinitely flexible. Instead of strings you can use Lisp expressions, whose return values will be used in the text. See the [http://www.gnu.org/software/emacs/manual/html_mono/autotype.html#Skeleton-Language Emacs Auto Type manual] for details.

== Webforum skeletons ==

A collection of skeletons for the common "BB code" of webforums. Bind to appropriate keys (below) and use together with VisualLineMode to conveniently write forum posts in Emacs.

    (setq skeleton-end-newline nil)
    (define-skeleton bb-italic
      "Make italic text."
      nil "[i]" _ "[/i]")
    (define-skeleton bb-bold
      "Make bold text."
      nil "[b]" _ "[/b]")
    (define-skeleton bb-underline
      "Make underlined text."
      nil "[u]" _ "[/u]")
    (define-skeleton bb-tt
      "Typewriter font."
      nil "[font=\"Courier New\"]" _ "[/font]")
    (define-skeleton bb-url
      "Prompt for URL and insert link."
      "URL: "
       "[url=\"" str "\"]" _ "[/url]")
    (define-skeleton bb-list
      "Start an unordered list."
      nil "[list][*] " _ "\n[/list]")
    (define-skeleton bb-point
      "Make a new list point."
      nil (unless (bolp) "\n") "[*] " _)
    (define-skeleton bb-img
      "Insert [img] ... [/img] tags."
      nil "[img]" _ "[/img]")
    (define-skeleton bb-indent
      "Insert [indent] ... [/indent] tags."
      nil "[indent]" _ "[/indent]")
    (define-skeleton bb-youtube
      "Insert [youtube] ... [/youtube] tags."
      nil "[youtube]" _ "[/youtube]")

As for key bindings, the following roughly matches AUCTeX's scheme:

    (global-set-key "\C-c\C-f\C-e" 'bb-italic)
    (global-set-key "\C-c\C-f\C-u" 'bb-underline)
    (global-set-key "\C-c\C-f\C-b" 'bb-bold)
    (global-set-key "\C-c\C-f\C-t" 'bb-tt)
    (global-set-key "\C-c\C-fu"    'bb-url)
    (global-set-key "\C-c\C-f\C-l" 'bb-list)
    (global-set-key "\C-cj"        'bb-point)
    (global-set-key "\C-c\C-j"     'bb-point)
    (global-set-key "\C-c\C-fi"    'bb-img)
    (global-set-key "\C-c\C-f\C-i" 'bb-indent)
    (global-set-key "\C-c\C-f\C-y" 'bb-youtube)
    (global-set-key "\C-c\C-fy"    'bb-youtube)

== Skeletons and abbrevs ==

You can combine the power of skeletons with abbrevs. Note that you need to activate AbbrevMode if you really want to just type `;ife' to insert the expansion. (The following posting was slightly edited by AlexSchroeder.)

 From: Miroslav Fikar <fikar@cvt.stuba.sk>
 Subject: Re: Templates in Emacs...
 Newsgroups: comp.emacs
 Date: 12 Oct 2001 18:07:28 +0200

Here is a small skeleton example from my fortran mode: typing `;ife' expands to the following fragment with the TextCursor placed in ().

 if () then
 else
 end if

Here's the code:

    (define-abbrev fortran-mode-abbrev-table ";ife"
      "" 'fortran-skeleton-if-else-endif)

    (define-skeleton fortran-skeleton-if-else-endif
      "Insert an if - else - end if region" nil
      > "if (" _ ") then" \n
      -3 "else" \n
      -3 "end if")

    (setq skeleton-end-hook nil)

[new]
abbrev only expands on word constituents. In fortran-mode, the semicolon is a word constituent. You can't just use ##;foo## in other modes ... this confused me greatly ;)

== Preventing skeleton/abbrev recursion ==

If you want to use abbrevs, but don't want abbrevs interacting with your skeletons, you can use this.

    (setq skeleton-further-elements '((abbrev-mode nil)))

##skeleton-further-elements## is buffer local when set. Its purpose is to effectively surround your abbrev expansion with ##let##.

    ;; actual snippet from skeleton.el
    (eval `(let ,skeleton-further-elements
     	   (skeleton-internal-list skeleton str)))

So my example causes the above code to expand into:

    (let ((abbrev-mode nil))
         (skeleton-internal-list skeleton str))

Effectivly turning off abbrev-mode while skeletons insert into this buffer.

See "Using Multiple Variables" below and then imagine how this feature opens the possibilities.

== Repeated Input ==

Here is another example which asks the user for repeated input. The key phrase to note in the ##skeleton-insert## !DocString is this:

: ##ELEMENT## may itself be a ##SKELETON## with an ##INTERACTOR##. The user is prompted repeatedly for different inputs. The ##SKELETON## is processed as often as the user enters a non-empty string.

    (define-skeleton hello-class
      "Example for repeated input."
      "this prompt is ignored"
      ("Enter name of student: " "hello, " str \n))

And assuming some very simple input, here's the result:

    hello, a
    hello, b
    hello, c

== Using the power of repeating skeletons ==

I like the way you can make a skeleton repeat until you don't want anymore input (see above), however I struggled until today to work out how to act on the str so that you can transform it how you will.

  (define-skeleton add-tags
    "Enter tags in any case and the output will be upcased."
     nil
  "Tags: "
   ((upcase (read-string "Tag: ")) ":"  str) ":" \n ;interacter=expression for complex read functions ->
						  ;including transforming strings.
   )

Gosh I like skeletons!

== Using Multiple Variables with Skeleton Mode ==

##define-skeleton## has a few limitations. You can't bind more than one variable at a time, and skeletons after the first ''must'' repeat.

The skeleton provides a) the two symbols ##v1## and ##v2## (preserved for the user) and b) `skeleton-read' to query for a string during the execution of the skeleton. Thus:

    (define-skeleton read-two-vars
      "Prompt the user for two variables, and use them in a skeleton."
      ""
      > "variable A is " (setq v1 (skeleton-read "Variable A? ")) \n
      > "variable B is " (setq v2 (skeleton-read "Variable B? ")) \n
      > "A: " v1 "    B: " v2 \n)

== More things to do with Variables in Skeleton Mode ==

  (define-skeleton vote
   ""
  nil
  >"|----------------+----------+--------------|" \n
  >"|Vote:           |For: " (setq v1 (skeleton-read "How many for? "))"    |Against: " (setq v2 (skeleton-read "How many against? "))"    |" \n
  >"|----------------+----------+--------------|" \n
  "|" (if (< (string-to-number v1)(string-to-number v2)) (insert "Not Carried                               |")
  (insert "Carried                                    |")) \n
  >"|------------------------------------------|" \n
  )

This is a use of unquoted S-expressions to both write immediate text and set variables that are to be reused later. As you can see, so long as the S-expression finally inserts text some numerical calculations can be done.

== Using Arbitrary Lisp Expressions ==

The skeleton language allows to evaluate arbitrary Lisp expressions when Emacs executes the skeleton program. This feature has two flavours: quoted s-expressions and unquoted S-expressions.

=== S-Expressions without Quotes ===

S-expressions without a quote must return a string. The skeleton program then inserts this string into the buffer. Example:

    (define-skeleton sexpr-example
      "Insert a silly example."
      ""
      > "Emacs version is: " emacs-version \n
      > "And time is: " (current-time-string))

=== Quoted S-Expressions ===

If you quote the sexpr, the skeleton program does ''not'' insert its return value, but discards it. You can use this to play some hackish tricks. The following example inserts a C-style comment in a box into the current buffer, like:

 /* **************************************************************** */
 /* **                        Lirum larum                         ** */
 /* **************************************************************** */

This is the skeleton:

    (define-skeleton insert-c-comment-header
      "Inserts a c comment in a rectangle into current buffer."
      ""
      '(setq str (skeleton-read "Comment: "))
      ;; `str' is set explicitly here, because otherwise the skeleton
      ;; program would set it, only when it is going to insert it into the
      ;; buffer. But we need to determine the length of the string
      ;; beforehand, with `(length str)' below.
      '(when (string= str "") (setq str " - "))
      '(setq v1 (make-string (- fill-column 6) ?*))
      '(setq v2 (- fill-column 10 (length str)))
      "/* " v1 " */" \n
      "/* **"
      (make-string (floor v2 2) ?\ )
      str
      (make-string (ceiling v2 2) ?\ )
      "** */" \n
      "/* " v1 " */")

Please note, however, that when you have reached this level of complexity, you probably should consider implementing it as a normal EmacsLisp function.

[:XhtmlSkeleton]
Here's another example of quoted sexps that might be more useful.

    (define-skeleton xhtml-trans-skeleton
      "Inserts a skeletal XHTML file with the DOCTYPE declaration
    for the XHTML 1.0 Transitional DTD"
      "Title: "
      "<?xml version=\"1.0\""
      (if buffer-file-coding-system
          (concat " encoding=\""
                  (setq v1
                        (symbol-name
                         (coding-system-get buffer-file-coding-system
                                        'mime-charset))) "\""))
      "?>\n"
      "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n"
      > "\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n"
      > "<html xmlns=\"http://www.w3.org/1999/xhtml\">\n"
      > "<head>\n"
      (when buffer-file-coding-system
            (indent-according-to-mode)
            (concat
             "<meta http-equiv=\"Content-type\" content=\"text/html; charset="
             v1 "\" />\n"))
      > "<meta name=\"Author\" content=\"" (user-full-name) "\" />\n"
      > "<title>" - str
      '(save-excursion (sgml-quote skeleton-point (point)))
      "</title>\n"
      "</head>" > \n
      > "<body>\n"
      > "<h1>" - str
      '(save-excursion (sgml-quote skeleton-point (point)))
      "</h1>\n"
      > - \n
      "</body>" > \n
      "</html>" > \n \n)

The quoted sexps provide proper HTML characters by running sgml-quote on the region, by first marking the point with ##-## and using `skeleton-point' in the sexp.  Once you start using ##-##, you can't use ##_## as the "interesting point".  This example also shows how you need to use ##>## at the end of lines before a newline is inserted in case indentation needs to go backwards because of a closing element.

== skeleton-pair-insert-maybe enhanced variant ==

Here follows an enhanced variant of ##skeleton-pair-insert-maybe##, that overcomes some of its limitations.

: ''(Please add an explanation of the limitations of ##skeleton-pair-insert-maybe## and how this enhaced version overcomes it.)''

    (setq skeleton-end-hook nil) ; do not insert newline after skeleton insertation

    (defvar myskeleton-pairs
      '((?\" . (?\" ?\" ?\" _ ?\"))
    	(?\( . (?\( ?\) ?\( _ ?\)))
    	(?\[ . (?\[ ?\] ?\[ _ ?\]))
    	(?\{ . (?\{ ?\} ?\{ _ ?\}))
    	(?\' . (?\' ?\' ?\' _ ?\'))
    	(?\` . (?\` ?\' ?\` _ ?\')))
      "Table of skeletons pairs. Maybe local to buffer.")

    (defun myskeleton-pair-insert (arg)
      "Inserts pairs."
      (interactive "*P")

      (let* ((chr (event-key last-command-event))
    	     (pair (assoc chr myskeleton-pairs)))
    	(if (null pair)
    	    (message "Character %s is not in `myskeleton-pairs'.")
    	  (cond ((and (listp arg) (not (null arg)))
    		 ;; Surraund current word with
    		 (save-excursion
    		   (when (not (looking-at "\\<"))
    		     (backward-word 1))
    		   (when (looking-at "\\sw")
    		     (let ((pl 0)
    			   (r (prefix-numeric-value arg)))
    		       (while (> r 1)
    			 (setq r (/ r 4))
    			 (setq pl (1+ pl)))

    		       (insert (make-string pl (nth 0 (cdr pair))))
    		       (forward-word 1)
    		       (insert (make-string pl (nth 1 (cdr pair))))))))
    	      (t (mapcar (lambda (not-used)
    			   (skeleton-insert
    			    (cons nil (cdddr pair))))
                         (make-list (prefix-numeric-value arg) 'not-used)))))))

    (define-key global-map (kbd "C-M-{") 'backward-paragraph)
    (define-key global-map (kbd "C-M-}") 'forward-paragraph)
    (define-key global-map (kbd "C-M-'") 'abbrev-prefix-mark)

    (define-key global-map (kbd "M-\"") 'myskeleton-pair-insert)
    (define-key global-map (kbd "M-`") 'myskeleton-pair-insert)
    (define-key global-map (kbd "M-'") 'myskeleton-pair-insert)
    (define-key global-map (kbd "M-{") 'myskeleton-pair-insert)
    (define-key global-map (kbd "M-(") 'myskeleton-pair-insert)
    (define-key global-map (kbd "M-[") 'myskeleton-pair-insert)

    ;; pairing for C-mode
    (defun my-skelpair-cmode ()
      (make-local-variable 'myskeleton-pairs)
      (setq myskeleton-pairs (copy-alist myskeleton-pairs))
      (remassoc ?\{ myskeleton-pairs)
      (add-to-list 'myskeleton-pairs '(?{ . (?{ ?} ?{ '(progn (indent-according-to-mode) nil) \n _ \n ?} '(progn (indent-according-to-mode) nil)))))

    (add-hook 'c-mode-hook 'my-skelpair-cmode)

##myskeleton-pair-insert## recognizes two types of prefix, one is sereveral universal arguments (C-u) and the other numeric prefix argument. In the first case it will surround the current word N times (N is how much you press C-u), or just insert pair N times (N is numeric prefix argument).

[:PairInsertion]
== Pair Insertion ==

See AutoPairs to insert parentheses, braces, quotes, etc. in matching pairs.

== Deletion ==

To delete empty pairs like '##()##' with a single keypress, we can [AdvisingFunctions advice] ##delete-backward-char## with the following code (borrowed from [http://code.google.com/p/emacs-textmate/ textmate.el]):

    (defvar skeletons-alist
      '((?\( . ?\))
        (?\' . ?\')
        (?\" . ?\")
        (?[  . ?])
        (?{  . ?})
        (?$  . ?$)))

    (defadvice delete-backward-char (before delete-empty-pair activate)
      (if (eq (cdr (assq (char-before) skeletons-alist)) (char-after))
          (and (char-after) (delete-char 1))))

If the cursor is between '##(##' and '##)##', pressing ##<backspace>## now deletes both characters. The variable ##skeletons-alist## is easily extended with more pairs, represented as single characters.

However, we can also remove pairs that are /not/ empty:

    (defadvice backward-kill-word (around delete-pair activate)
      (if (eq (char-syntax (char-before)) ?\()
          (progn
            (backward-char 1)
            (save-excursion
              (forward-sexp 1)
              (delete-char -1))
            (forward-char 1)
            (append-next-kill)
            (kill-backward-chars 1))
        ad-do-it))

This modifies the behavior of ##backward-kill-word##, normally bound to ##<C-backspace>##. For example, if the cursor is at the '##w##' in '##((word))##', ##<C-backspace>## gives '##(word)##'. It only works for pairs listed in the [EmacsSyntaxTable syntax table], however.

=== Regular Expressions ===

The code above only deletes single-character pairs. To remove skeletons that consist of more characters, we can use regular expressions:

    (defvar regexp-pairs-alist
      '(("\\[i\]"         . "\\[/i\\]")
        ("\\[b\]"         . "\\[/b\\]")
        ("\\[u\]"         . "\\[/u\\]")
        ("\\[font[^]]*\]" . "\\[/font\\]")
        ("\\[url[^]]*\]"  . "\\[/url\\]")
        ("\\[list\\]"     . "[\n ]*\\[/list\\]")
        ("\\[\\*\\]"      . "")
        ("\\[img\\]"      . "\\[/img\\]")
        ("\\[indent\\]"   . "\\[/indent\\]")
        ("\\[youtube\\]"  . "\\[/youtube\\]")))

    (defadvice delete-backward-char (around delete-empty-regexp activate)
      (unless (catch 'loop
                (let (regexps start end)
                  (dolist (regexps regexp-pairs-alist)
                    (and (looking-at (setq end (cdr regexps)))
                         (looking-back (setq start (car regexps)))
                         (progn (replace-match "")
                                (looking-at end)
                                (replace-match "")
                                (throw 'loop t))))))
        ad-do-it))

I use this code for "BB code" tags in forum posts. With skeletons, I can wrap the point or region in '##[i][/i]##' with a single keystroke, and delete empty pairs with another -- ##<backspace>##.

But there's more! Remember when deleting nonempty pairs above, the pair had to be listed in the syntax table? Not with regular expressions:

    (defadvice backward-kill-word (around delete-regexp activate)
      (unless (catch 'loop
                (let (regexps start end (level 1))
                  (dolist (regexps regexp-pairs-alist)
                    (when (looking-back (setq start (car regexps)))
                      (replace-match "")
                      (setq end (cdr regexps))
                      (save-excursion
                        (while (re-search-forward
                                (concat "\\(" start
                                        "\\)\\|\\("
                                        end "\\)") nil t)
                          (if (looking-back start)
                              (setq level (1+ level))
                            (when (= 0 (setq level (1- level)))
                              (replace-match "")
                              (throw 'loop t)))))
                      (throw 'loop t)))))
        ad-do-it))

Now, if the cursor is at the '##t##' in '##[i]text[/i]##', ##<C-backspace>## gives '##text##'. The advice recognizes nested tags.

== More Information ==

Read the function documentation for ##skeleton-insert## to learn about creating more complex skeletons.

----
CategoryCode CategoryTemplates CategoryDotEmacs CategoryParentheses
