= :MON-PACKAGES =

Following is organized roughly according to the load order whilst trying to convey how MON contextualizes packages. For a more detailed outline w/re load order :SEE [[#MonLoadOrder]] below.

== :MON-STARTUP-FILES ==

* Lisp:monDOTemacs.el -- Points to a local directory and load mon-site-local-defaults.
* Lisp:mon-site-local-defaults.el -- An example configuration of MON's `site-local-private.el' which acts as a bootstrap for mon-default-loads and helps to obfuscate information which needn't be revealed other packages.
* Lisp:mon-default-loads.el -- Setup the globals and base system portability.
* Lisp:mon-default-start-loads.el -- Setup any Emacs and Third party packages required.
* Lisp:mon-w32-load.el -- w32 specific features which must be present or are better left segregated.
* Lisp mon-GNU-load.el -- GNU/Linux specific features. Mostly for quick reconfiguration of Slime related stuff prior to slime-loads.el
* Lisp slime-loads.el -- Slime is a moving target with multiple backends for multiple languages. This is for sanity.
* Lisp:mon-keybindings.el -- Set global keybindings and mode specific stuff.

== :MON-UTILS ==
The package mon-utils is the entry point which loads the rest of the system and specifically any mon-*.el and naf-mode-*.el packages.

* Lisp:mon-utils.el -- (MonUtils) This package is the entry point that loads everything else below.
* Lisp:mon-dir-locals-alist.el --
* Lisp:mon-dir-utils.el -- Provides a collection of handy functions and interactive commands for working with directories and files.
* Lisp:mon-insertion-utils.el -- Provides insertion related utilities, templates and string building/manipulation procedures that ease routine chores and interactive command invocation.
* Lisp:mon-replacement-utils.el -- Provides a collection of routines and commands and abstracts some commonly encountered procedures for processing regexps with their replacements.
* Lisp:mon-regexp-symbols.el -- Provides a collection of Symbols bound to lisp lists of regexp/replacement pairs. Allows simple easy interactive command invocation using symbols as arguments to containing lists of regexps.
* Lisp:mon-time-utils.el (EbayTime) --
* Lisp:mon-testme-utils.el 

=== :MON-STANDARDS ===
* Lisp:mon-cl-compat.el -- This is intendeed to be used as a drop-in replacement for the cl-seq.el When compiling your packages: (eval-when-compile (require 'mon-cl-compat))
* Lisp:mon-cl-compat-regexps.el -- Provides regular expressions for replacing the symbol-names from the cl-seq.el package with a `cl::' prefix
* Lisp:mon-empty-registers.el (EmptyRegisters) -- Provides utilities for filling/emptying register locations en masse. Also provides interactive tools for register centric coercion, manipulation, round-tripping of chars, strings, etc.
* Lisp:mon-hash-utils.el -- Provides a collection of procedures to extend Emacs lisp hash table functionality.
* Lisp:mon-name-utils.el -- procedures to rotate, combine, and permute string-like name forms
* Lisp:mon-rename-image-utils.el (RenameImageUtils) -- Provides utility functions for working with images and EmacsImageManipulation.
* Lisp:mon-tramp-utils.el -- Provides cross platform utilities for working with tramp. This package should be compatible with both GNU/LINUX and w32 systems and helps MON with Emacs portability across environments.

=== :MON-EXTRAS ===

* Lisp:mon-boxcutter.el -- For initializing w32 screen captures from Emacs using Matthew D. Rasmussen's Boxcutter screen-capture executables: boxcutter-fs.exe and boxcutter.exe
* Lisp:mon-color-utils.el -- Provides an assembled set of routines for manipulations/examinations of 'color'.
* Lisp:mon-mysql-utils.el (MySqlHelp) -- Provides interactive procedures for stripping content from MySQL query result tables.  Also, provides an alist of MySQL help categories and topics and a rudimentary completion functionality for accessing MySQL's `mysql' client help facility.
* Lisp:mon-rename-image-utils-supplemental.el --
* Lisp:mon-url-utils.el -- Provides utilities for interactively calling URL data lookups and for in
;;; buffer modification of web/internet scrapes.
* Lisp:mon-wget-utils.el -- Provides lightweight routines for pulling files with wget.
* Lisp:mon-get-mon-packages.el 
* Lisp:mon-cifs-utils.el -- (MonCifsUtils) Provides utilities for mapping and mounting a CIFS domain using auth-source. Common Internet File System protocol, e.g. successor to the SMB (Server Message Block) protocol with the Samba Server.
* Lisp:google-define-redux.el -- Provides extensions for Lisp:google-define.el

=== :MON-DOC-UTILS ===

* Lisp:mon-doc-help-utils.el -- (ReferenceSheetHelpUtils) (MonDocHelpUtilsDictionary)
* Lisp:mon-doc-help-utils-supplemental.el -- Provides functions and vars required to bootstrap mon-doc-help-utils 
* Lisp:mon-doc-help-pacman.el -- Some help functions for using the package manager with the GNU/Linux Arch distribution.
* Lisp:mon-doc-help-CL.el -- Some Emacs Lisp help functions for using Common-Lisp functions (loop, do, etc.)
* Lisp:mon-doc-help-proprietary.el -- Extends mon-doc-help-utils with ms w32 related docs.
* Lisp:mon-iptables-regexps.el -- Provides interactive utilities for converting iptables short flags to long flags.  Also provides procedures for using Emacs help-mode to document the order of position for the symbols, flags, etc. used with `iptables' AKA `netfilter'.
* Lisp:mon-iptables-vars.el -- Provides gigantic alist `*mon-iptables-alst*' needed for use with mon-iptables-regexps
* Lisp:perlisisms.el (Perlisisms) -- 
* Lisp:STING-software-engineering-glossary.el --

=== :EBAY-TOOLS ===

* Lisp:ebay-template-mode.el -- 
* Lisp:ebay-template-tools.el -- 

=== :NAF-MODE ====

* Lisp:naf-mode.el -- naf-mode is a major mode for editing NAFs (Name Authority Files). naf-mode provides utilities for working with and unifying authority records of various public accessible datasets LOC, BNF, ULAN, OCLC, Wikipedia, IMDB, etc. This package provides the core naf-mode facilities and require
statements for loading the other naf-mode-* packages below.
* Lisp:naf-mode-faces.el -- 
* Lisp:naf-mode-insertion-utils.el -- 
* Lisp:naf-mode-replacements.el -- 
* Lisp:naf-mode-classes.el -- 
* Lisp:naf-mode-db-fields.el -- 
* Lisp:naf-mode-db-flags.el -- 
* Lisp:naf-mode-dates.el -- 
* Lisp:naf-mode-french-months.el -- 
* Lisp:naf-mode-nation-english.el -- 
* Lisp:naf-mode-nation-french.el -- 
* Lisp:naf-mode-nationality-english.el -- 
* Lisp:naf-mode-nationality-french.el -- 
* Lisp:naf-mode-intnl-city-names.el -- 
* Lisp:naf-mode-city-names-us.el -- 
* Lisp:naf-mode-state-names.el -- 
* Lisp:naf-mode-regions.el -- 
* Lisp:naf-mode-publications-periodicals-english.el -- 
* Lisp:naf-mode-publications-periodicals-french.el -- 
* Lisp:naf-mode-publications-periodicals-intnl.el -- 
* Lisp:naf-mode-institution.el -- 
* Lisp:naf-mode-students-of-julian.el -- 
* Lisp:naf-mode-events.el -- 
* Lisp:naf-mode-english-roles.el -- 
* Lisp:naf-mode-french-roles.el -- 
* Lisp:naf-mode-awards-prizes.el -- 
* Lisp:naf-mode-group-period-styles.el -- 
* Lisp:naf-mode-art-keywords.el -- 
* Lisp:naf-mode-benezit-flags.el -- 
* Lisp:naf-mode-ulan-utils.el -- 
* Lisp:naf-mode-xrefs.el -- 

[:MonLoadOrder]
== :MON-LOAD-ORDER ==

Roughly the sequence with which MON brings his Emacs' systems up. Note, not all of these libraries are required to get a working system but as MON stacks dependencies it may be helpful to remember that anything loaded from naf-mode.el or that has the ``naf-'' prefix can be ommitted. Libraries with a ``-utils' suffix will most likely get pulled in by a require statement. Libraries with a ``supplemental'' suffix are an attempt to provide feature subsets without requiring you to load the full Monty. Eventually with some judicious use of autoloads MON should be able to provide these with a lighter footprint. Likewise, if/when a transition to defcustoms occurs you might be able to rule out using a heavy set. Though, at that point you'll be stuck in defcustom hell :P ...

<pre>

¦monDOTemacs.el
¦► mon-site-local-defaults.el
¦►► mon-default-loads.el
¦►►► mon-default-start-loads.el
¦►►►► mon-w32-load.el
¦     mon-GNU-load.el
¦►►►►► slime-loads.el
¦►►►►► mon-keybindings.el
¦►►► mon-utils.el
¦►►►► mon-cl-compat.el
¦►►►►► mon-cl-compat-regexps.el
¦►►►► mon-regexp-symbols.el
¦►►►► mon-time-utils.el
¦►►►► mon-replacement-utils ;; :BEFORE mon-dir-utils.el naf-mode-insertion-utils.el
¦►►►► mon-dir-locals-alist.el
¦►►►► mon-dir-utils.el
¦►►►► mon-cifs-utils.el
¦►►►► mon-insertion-utils.el
¦►►►► mon-testme-utils.el
¦►►►► naf-mode-insertion-utils.el
¦►►►► mon-url-utils.el
¦►►►► mon-hash-utils.el
¦►►►► mon-doc-help-utils.el
¦►►►►► mon-doc-help-proprietary.el
¦►►►►► mon-doc-help-pacman.el
¦►►►► mon-doc-help-CL.el
¦►►►► mon-tramp-utils.el
¦►►►► naf-skeletons.el
¦►►►► naf-mode.el
¦►►►►► mon-name-utils.el
¦►►►►► naf-mode-faces.el
¦►►►►► naf-mode-institution ;; :AFTER naf-mode-faces.el
¦►►►►► naf-mode-db-fds.el
¦►►►►► naf-mode-db-flags.el
¦►►►►► naf-mode-ulan-utils.el
¦►►►►► naf-mode-publications-periodicals-french.el
¦►►►►► naf-mode-publications-periodicals-english.el
¦►►►►► naf-mode-publications-periodicals-intnl.el
¦►►►►► naf-mode-dates.el
¦►►►►► naf-mode-english-roles.el
¦►►►►► naf-mode-french-roles.el
¦►►►►► naf-mode-nation-english.el
¦►►►►► naf-mode-nation-french.el
¦►►►►► naf-mode-nationality-french.el
¦►►►►► naf-mode-nationality-english.el
¦►►►►► naf-mode-state-names.el
¦►►►►► naf-mode-city-names-us.el
¦►►►►► naf-mode-intnl-city-names.el
¦►►►►► naf-mode-regions.el
¦►►►►► naf-mode-art-keywords.el
¦►►►►► naf-mode-events.el
¦►►►►► naf-mode-group-period-styles.el
¦►►►►► naf-mode-benezit-flags.el
¦►►►►► naf-mode-awards-prizes.el
¦►►►►► naf-mode-students-of-julian.el
	Following naf-mode files are still in development/transition but also loaded from naf-mode.el
¦¦►►►►► naf-mode-abbrevs.el
¦¦►►►►► naf-mode-awards-prizes.el
¦¦►►►►► naf-mode-bibliographic-entry.el
¦¦►►►►► naf-mode-classes.el
¦¦►►►►► naf-mode-ulan-help-docs.el
¦¦►►►►► naf-mode-xrefs.el
¦►►►► ebay-template-mode.el
¦►►►► mon-empty-registers.el
¦►►►► mon-iptables-vars.el
¦►►►► mon-iptables-regexps.el
¦►►►► mon-mysql-utils.el
¦►►►► mon-bzr-utils.el -- Not provided here yet.
¦►►►► mon-eight-bit-raw-utils.el -- Not provided here yet.
¦¦►►►► naf-mode-sql-skeletons.el -- Not provided here. It is mostly a collection of SQL statement.
¦¦►►►► smith-poster-utils.el --  Not provided here.

</pre>

 =]

/s_P\

[new:stepnem:2010-02-05 08:09 UTC]
I wonder why your packages don't adhere to Elisp library header conventions.
Also, some of the `Lisp' links above don't work (missing the colon).

[new:mon_key:2010-02-06]
<pre>

Yes, mon-GNU-load.el and slime-loads.el are not provided here. These are however
referenced in the comments of some of my other files so I display them. I don't
believe there is anything in these files which should be of any interest to
others. Have you found a requirement for them that is causing you problems?

  [Note: thank you for your reply (which I only noticed now -- I was using the RSS
  feed of RecentChanges in a mistaken belief that it would "work"). Unfortunately its
  length and form make it a bit hard to continue the discussion, so I'm doing so
  in-place like this -- stepnem]

    I think the RSS only "works" when the change is _non_ flagged minor.  -- [[mon_key]]

  No, I just found it weird: the lines *look* like a Lisp: link, but in fact are
  not -- they're missing the colon. Now I know it was intentional and not an error,
  but I still find that somewhat confusing. Whatever.

    I can't come up with a better way to communicate the information that isn't
    needlessly verbose -- [[mon_key]]

Regarding my headers. 

I use a template to generate them 
</pre>
:SEE :FUNCTION `mon-insert-file-template' in :FILE Lisp:mon-insertion-utils.el 

<pre>
For the most part I agree, my packages _should_ adhere to the header conventions.

When I first wrote the template I wasn't aware of the rationale behind using a
canonical header. I glanced at the docs and what I saw felt ugly so I rolled my
own.

  That's a rather lame reason for rolling one's own.

    NO! That is the best reason for rolling your own :) From a selfish
    perspective its my code I can do as I please with it. From a populist
    perspective if/when I do change the headers I will do so having gained
    experiential knowledge justifying my adoption of convention rather than
    simply blindly steering down the path because I was told to do so.
    "Sheeps go to heaven. Goats go to hell." -- [[mon_key]]

Since then, the need for adhering to this convention has become more clear to me.  
Unfortunately it will be a bit tedious adjusting my existing headers to
conformity and I simply haven't made the switch yet... I would prefer to make
this change all at once in one unified commit so I don't instantiate unnecessary
diff/merge conflicts. Note, when this occurs you can expect a Bazaar or HG repo
to be made available. I'm still working out some kinks :)

This said, there are some conventions of the ``standard'' header that I dislike. 

FWIW they are as follows:

The two semi-colon convention used in some locations is not in keeping with
other Lisp's commenting conventions and does not necessarily reflect the
context of the thing being commented...

Likewise, the convention isn't even internally consistent. In some places one
is recommended to use two colons and in others to use three. The distinction
made by the parser is reliant on whitespace at BOL. To the extent that the
header conventions are _actually_ canonical this reliance on whitespace has
remained workable. In practice adherence to this convention places unwarranted
power into the hands of the emacs-devels/maintainers allowing them to enforce
an unspecified specification. I.e. MON, your headers aren't compliant :) 

  IIUC the only convention we are speaking about here is the library headers
  section.
  If you look at the actual code (lisp-mnt.el), you see it only relies on section
  headers having at least three semicolons followed by some amount of
  whitespace, which actually leaves a lot of space for adjustment (see esp. the
  docstring of `lm-header-prefix' in the same file).

    My primary objection is w/re the whitespace conventions (blank line as
    delimiter, <TAB> prefixed continuations, etc.) For example, when I first
    wrote my header template I was encountering ^M (char 13) ugliness on w32
    with .gz'd libraries. This was due to a sort of bug in the way that
    particular Emacs build interacted with a rogue gunzip in path.  The problem
    never materialized on GNU systems so it is unlikey that you were bothered by
    it... That said, this ``bug'' did manifest as aesthetically and drew my
    attention to the wspc at BOL as a potential source of errors.  

  That being said, I personally see no problem with the de-facto standard either
  (i.e. three semicolons for a heading, two for the rest). 

    De facto standards do not a standard make. The headers section is simply a
    convention. That Eric S. Raymond authored lisp-mnt.el circa summer 1992 says
    quite a lot about the nature of the convention being upheld. When one
    considers the contemporary political climate surrounding Lisp at that time
    (Xemacs/Lucid/Emacs schism, pending ratification of ANSI CL, etc.) it should
    become more evident why some of these conventions were adopted... some turf
    battles were being fought in the headers (and parsing thereof). How involved
    is ESR with Emacs project now? Lucid is dead. JWZ got a bar. RMS passed the
    torch.  Apropos these things the ``convention'' which ought to be upheld is
    that things change. -- [[mon_key]]

  Although it is different from usual Lisp code commenting conventions, I don't
  think that's really a problem -- it's a header section, not a normal
  comment. 

    It is a comment first. The convention that `;' begins a comment is a
    syntactic fact w/ lisps.  That this convention is leveraged to accomodate
    emacs lisp header conventions does not undo the reality that the header is
    first and foremost a comment. -- [[mon_key]]

  The only inconvenience I can think of off the top of my head is using
  outlining, e.g. if you would define the highest level with four semicolons --
  but as said above, the implementation actually makes that possible even now.

    This is not a fair assertion and a strawman. lsp-mnt.el routinely binds
    `case-fold-search' and other of its parsing procedures rely on
    `emacs-lisp-mode-syntax-table'.  Reliance on lsp-mnt.el means adopting these
    case and syntactic perspectives. Again, there are some underlying political
    implications (prob. historic) but their presence will color ones reliance on
    this library. -- [[mon_key]]

When one considers adopting an alternative form of field delimiter for package
headers it is clear that reliance on semi-colon padding and whitespace
placement alone is a stupid and error prone way to facilitate header parsing.
It would be _much_ more reasonable to use a dedicated token(s) or cookie(s)
i.e. my use of `►►►' `◄◄◄' to flag the functions in my packages. Moreover, it
would be even better to provide package authors to declare _their_ preferred
delimiting tokens in the file header. These might be placed in the mode `-*-'
or `file-local-variables-alist' and might be useful for directing
`hack-local-variables' to identify the users preferred delimiter tags.

  Well, maybe. I haven't felt the need. If you do, just implement it and fight
  for its adoption.

    I did implement it :) Fighting for its adoption is a non-starter. If others
    find utility in my approach they will do similarly. This said, as an
    exercise you may find it interesting to examine Thierry Volpiatto's headers
    and those of the anything-*.el which implement arbitrarily defined
    ``tags'' to flag areas of interest within header comments.  My understanding
    is that Thierry is extending some of the ideas from the eiv package. Which
    is to say, I'm certainly not the only _current_ non-devel/maintainer
    attempting to extend the sparse semantics of elisp headers. -- [[mon_key]]

It is worth considering, that my consistent use of only the three colon BOL is
easily remedied with a quick rectangle crop. The same can not be said of the
combined use of two and three colon BOL's.

The `-*-' convention, that the cookie should appear after the description is
not in keeping with vast amounts of legacy Lisp code which has it at line 1.
This is a convention instantiated by a dated political beef, it has little to
do with shell scripting as purported in the docs.

The `Copyright' line placement is for the benefit of parsers not humans.
It can be placed in any conspicuous location and _ought_ to come after
any relevant discussion of the thing being protected. Why should users be
required to scan through a bunch of boiler plate legalese in order to get an
understanding of the features a package provides?

The `License' line should be tightly coupled with the copyright line but isn't.

The current Copyright and License lines placement conventions do not
accommodate incorporation of GFDL well. This is an oversight that should not
continue.

The `Version' line usage is compromised in lieu of contemporary distributed
VCS'.
	
  I don't think so. I see the two as orthogonal -- you can use whatever VCS you
  want for development, but it still makes sense to release the package and use
  the Version header.

   You may see these as orthogonal but whomever wrote the comments in the header
   of lisp-mnt.el didn't necessarily share that opinion:

   ,----
   |;;    * Version line --- intended to give the reader a clue if they're
   |;; looking at a different version of the file than the one they're accustomed
   |;; to.  This may be an RCS or SCCS header.
   `----

   :SEE-ALSO comment in `lm-header'

   ,----
   | ;;   RCS ident likes format "$identifier: data$"
   `----

   -- [[mon_key]]

The `History' line line usage is compromised in lieu of contemporary
distributed VCS'.

  Same as above -- you shouldn't expect every user to be interested in checking
  out your repository just to see what changed since the last version.

    I agree. However, this is not my point. The Emacs lisp libraries distributed
    with don't carry a ``History'' or ``Change Log'' either. They maintain these
    in a separate location, namely ChangeLog. Which seems to belie your point
    i.e. The emacs-devels/maintainers _expect_ users to examine a separate
    source to see what has changed since the last version. Obv. it is worthwhile
    to indicate within one's source when/where/how a change (in particular a
    potentially breaking one) has occurred. 
    
    My approach to this has been to indicate inline when a procedure or variable
    was first authored with:

    ;;; :CREATED <Timestamp: #{2010-02-25T12:20:27-05:00Z}#{10084} - by MON>

    When a symbol is modified significantly or in a potentially breaking way:

   ;;; :MODIFICATIONS <Timestamp: #{2010-02-25T12:24:07-05:00Z}#{10084} - by MON>
   ;;; Did something which does something different or breaking.

    When a symbol is renamed with:
    
    ;;; :RENAMED `old-name' -> `new-name'

    When a symbol was sourced from a third party with:

    ;;; :COURTESY Some Name :HIS some-file.el :WAS `the-old-symbol-name'

    I find the use of colon prefixed upcased symbols useful because it is easier
    to parse both visually and programatically. Moreover, this approach allows
    the user examining the source associated with a particular function from
    *Help* to immediately glean a good deal of contextual information _without_
    having to jump to the files ``Change Log'' header or to visit a VCS log.
    The downside is that source is quite a bit more verbose and often appears
    can appear dirty. My longterm hope is to add procedures to code-fold these
    comments. 

    Likewise, you may have noticed the `►►►' cookie which suffixes all
    of my docstrings. I have gone to considerable lengths to xref related
    functions in docs. This is largely a manual process. Over time the number of
    xrefs within a docstring can become quite large. And it would seem that this
    is why conventional wisdom has been to _not_ include extensive xrefs.  I
    reject this perspective. So long as one consistently places textual markers
    at the beginning and end of these xrefing sections it is a relatively
    trivial task for Emacs to fold over sections with a disclosure widget.

    </pre>

    :SEE http://en.wikipedia.org/wiki/Disclosure_widget

    <pre>    

    For example, following might be used to indicate a disclosure widget:
    
     :SEE-ALSO ►►►

    Which, when expanded reveals:
    
     :SEE-ALSO { ... 
                 Lots of xref'd functions/vars here 
                 ... }
      ►►►
     
     -- [[mon_key]]

The `Created' line should use a more robust time stamp and should be mandatory
with _strong_ emphasis encouraging on ISO-8601 conformity. 

Likewise, this line should not be considered "of historic interest" only.
It is exceedingly useful for user packages distributed separate from Emacs.
Moreover, in lieu of contemporary distributed VCS the created line conveys
more data than either the `Version' line or `History' lines. 

The `Author' line convention is spammer fodder.

  I don't see how; 

   Post your email address to an EmacsWiki page and see how long before it gets
   harvested by spammers :) -- [[mon_key]]

  and the Maintainer: header makes it possible to send bug reports
  semi-automatically.

    Yes, and automation is the spammers primary currency. -- [[mon_key]]

There are any number of better ways to implement a central registry of package
authors that might allow users to contact a packages author and that would
protect both the authors privacy and the users.

  Definitely. There is nearly always any number of better ways to do _anything_.
  Just do it.

    As a lone user there is no utility for me to gain in attempting
    this. Moreover that one of the ``package'' packages will eventually wind up
    implementing this I've no doubt. -- [[mon_key]]

I also have a firm belief that when AI occurs it will wish to introspect.
I've no reason to suspect that such a thing will necessarily be well
intentioned.  This may seem nuts to many but I don't wish to be participant to
such introspection without good cause. There is simply no reason to attach a
unique identifier like ones' common "True name" for untold AI to investigate
arbitrarily.  In so much as "I am that I am human" others of my type can reach
me easily enough if need be.

The `Keywords' line is useful only to the extent that `finder-by-keyword' works.
That function is compromised by the lack of any sort of canonical data
dictionary, thesaurus, etc. The literature re these mechanism and their
correct implementation is vast and well explored. The conventional idioms
explored in the literature are robust and reliable.

  Yes, the current implementation of `finder-by-keywor' is braindead (actually, the
  whole finder.el leaves much to be desired). I'm probably going to post to
  emacs-devel about it in near future.
  Here is a possible implementation doing something actually useful (just a POC,
  relies on some cl functionality). Note it uses the `Keywords:' header:

</pre>
{{{
 (defun finder-by-keyword (key)
  "List packages matching a given keyword."
  (interactive
   (list
    (completing-read
     "Keyword: "
     (mapcar (lambda (x) (and (symbolp x) (symbol-name x)))
             (remove-duplicates (apply 'append (mapcar 'caddr finder-package-info))))
     nil t)))
  (finder-list-matches key))
}}}
<pre>

    Thanks for the code. Is your intent here to shadow the existing
    `finder-by-keyword'?  Does not the `symbol-name' invocation intern all the
    matched symbols? However useful this POC may be it doesn't rise above the
    fundamental deficiencies of finder.

    FWIW mon-doc-help-utils.el is an attempt to codify a thesaurus of standard
    Emacs functions and vars in a manner somewhat similiar to finder. However, I
    fundamentally disagree with the finder approach. I first became aware of this
    disagreement after reading some posts on emacs-devel by Ted Z in early 2009. 
    Ted was attempting to improve finder's tag parsing routines to
    accomodate/incorporate erroneous, wayward, or arbitrarily user instantiated
    ``non-standard'' tags -- the endeavor amounted to tacit accomodaton of user
    whimsy via synonym rings or tag cloud. It became quite clear to me then that
    finder is crippled by its lack of an extensible but controlled vocabulary
    which is what is needed to properly accomplish a code catalog.

    You have may noted that many of the procedures in mon-doc-help-utils et al 
    merely provide giant docstrings. What you may not have noticed is that
    most of these docstrings are presented in such a way as to easily convert
    them to plists. I've attempted to delimit `conceptual section' in a given 
    `mon-help-*' functions as follows:

    ;; :SOME-CONCEPT
    `some-fncn-var'
    `some-fncn-var1'
    { ... lots more ... }
    `some-fncn-var1'

    Some of these lists can be quite extensive. Obv. it would be easier to pack
    them into a multiline elisp list structure and then unpack them into the
    docstring programatically. That said, in so doing it becomes difficult to
    organize the lists and/or identify missing terms, duplicates, etc. What I am
    attempting with these gigantic one symbol per line docstring lists is to
    accumulate a reasonably significant coverage of the base emacs library and
    at some opportune parse these docstrings out to formal emacs lisp
    lists. Until then keeping the lists monolithic string has allowed me to
    rapidly identify, change, modify the basic scope.  Since beginning this
    project (circa late Spring 2009) I've identified a number of idiomatic ways
    to conceptualize the data and have also been able to identify some potential
    pitfalls and dead ends. I am quite confident that these could only have been
    gleaned through trial and error and manual string editing. Other similar
    approaches in this arena such as icicles, anything, finder, etc. appear to
    have first considered the task as simply programattic/iterative. However
    beneficial these tools may be I think their approach is a dead end w/re to
    catalog generation. It is impossible to artificially improve the breadth of
    a knowledge base without first identifying the bounds of the
    known. It is only after you have surmised the scope of your library that you
    can sort the books. In essence this is what mon-doc-help-utils is about.
    -- [[mon_key]]

Emacs is _embarrassingly_ capable of integrating these idioms, yet it doesn't
because doing so would increase the memory footprint by a MB or two. This is
so unbelievably unfortunate that I find it difficult to play along. This
particular emperor is not only naked he's the lead in a porn flick that co
stars a goat and a donkey!

The `Commentary' line is only loosely coupled with the Keywords line. The two
should form a close pair. Also, it is like the `Keywords' field `Emacs Distribution'
eccentric, that is, externally distributed packages don't (by default) benefit from the
finder facilities.  This is classism plain and simple. Whats good for one pig
should be good for them all.

An equitable solution to finder/keywords/commentary concerns is easily had:

</pre>
:SEE http://www.gnu.org/software/idutils/  
<pre>

Emacs devels could formally integrate the Idutils tool suite and provide a
lisp interface to the primitives instead of secreting away the bespoke gutted
version they currently distribute to facilitate the doc snarfing
primitives. This would allow users far more control of what gets indexed and
when and because the index into the Idutils database is stored in binary form,
it is _FAST_ and it isn't required that everything be indexed _only_ at build
time. Eli Z is listed as a contributor to this package and IIRC he and Juri
L. have had public discussions on the topic so one assumes that what is being
proposed is possible.

The Documentation line is described as ``deprecated'' yet it is a more apt
descriptor of the the enclosed content than ``Commentary''.

The `Change Log' line should be contain a dash e.g. Change-Log. It really is
rather ugly to comply with that white space. You don't see Emacs' own ChangeLog
using it either. Moreover, that Emacs packages don't use this field and store
their changes in ChangeLog is a good indicator of its utility for externally
distributed packages. This field is, like its `History' and `Version'
counterparts, compromised in lieu of contemporary distributed VCS'.

The `FILENAME ends here' convention should mandate an EOF string.
EOF's are a _CONVENTION_ of great utility and using unencumbered by whitespace
issues makes good sense. There is no reason to expect that Emacs is or will be
the only program processing/parsing a package. Obv. inserting a literal Control-D
(e.g. ASCII 4, \x04) can be problematic when one is moving code around outside
Emacs but by substituting the literal with a simple text token like EOF one can
convey the same information and remain unencumbered by whitespace issues.

  ASCII ^D being EOF is a common misconception. Read up about ASCII and EOF.
  Google is your friend.

    I believe you have misunderstood me. I am suggesting that _any_ token
    comprised of a contiguous non-whitespace delimited string might be used as
    an EOF. For my puposes I use the string token "EOF" to this effect. 
    -- [[mon_key]]

  The main purpose of the `foo ends here' line is just to be sure it's the whole thing,
  i.e. not truncated.

    This may be the purpose and convention for emacs and elisp, it is worth
    noting that ANSI-CL provides explicit support to declare the terminating
    token when reading a stream, I am quite positive that there are other uses
    for an ``EOF'' token (literal or otherwise) than to simply ensure that a
    Emacs read in the file expected. Again, I would suggest that this
    paritucular manifestation of the convention arose from certain political
    perspectives regarding Xemacs/Emacs/Lucid/Common-Lisp. --[[mon_key]]

You'll note, I also don't use defcustom forms. I'm not sure that I can ever
fully transition to using that facility as currently provided.

I find the current interface confusing, somewhat kludgey, and often abuses my
expectations. I loathe those situations where custom arbitrarily binds globals
behind my back. Not only is it difficult to detect this, but it is also
difficult to locate the change once detected. So, I prefer to set my variables
by hand. Obv. this may be a big detractor for some users wishing to incorporate
mon-*.el packages. Given my distaste for custom I'm not sure how best to
approach increased integration with Emacs' custom interface other than to expect
that users will take a glance at the source.

Likewise, I'm not convinced that integration of the current custom interface is
a good use anyone's time. My intuition is that with the new Eieio/EDE
integration and the prospect of integration of a package facility coupled with
the _inevitability_ that Emacs will soon provide Bazaar support out of the box
(i.e. a built-in distributed version control system) will soon render some
aspects of the current defcustrom/defgroup specification moot. Integration of
any of these facilities: EIEIO, EDE, Bazaar, Package support, is of itself a
game changer for Emacs - collectively they will radically alter the scope of how
Emacs extensions are delivered. I simply can not believe that the current
defcustom facility will be capable of supporting this change.

  I also believe custom is horrible. I usually only use it sometimes to browse
  through available variables, then simply add the needed forms into my init file.
  It's a standard, nevertheless, and I don't see any problem in using `defcustom'
  instead of `defvar' when writing Emacs packages.

    This is good advice. Thank you. -- [[mon_key]]

So, to come full circle, Emacs' existing header conventions are a complicated
issue for me and I'm not convinced that the header conventions aren't due for a
correction first. Obv. this would be *a lot* of work. So the cruft persists. It
may be worth asking why it is that you feel compelled to have your header files
conform to Emacs conventions? What are the benefits?

  See above. Even from purely esthetic point of view, I find them nicer than yours.
  
    What about the GFDL? Where do external packages put that license? At the top
    of the header?  This is an aesthetic convention that is not well
    reflected/considered by emacs-devels/maintainers because core lisp code is
    distributed and maintained with boilerplate and ``include'' statements.  It
    would be a great exercise to manually examine the headers in the
    Emacs-mirror, ELPA, EmacsWiki to see how third-party authors accomodate
    copyright concerns in file headers. My impression is they simply do not
    mirror those of the core Emacs lisp packages.  
    -- [[mon_key]]

The only rationale that I can find is to consistently comport with third party
packaging tools.  To the extent that none of these are yet blessed why should
they adhere to the existing conventions either? AFAIK they don't now and have
parsing routines for extracting wayward headers already. IMHO This is one of
these areas where Emacs is broken not the inverse...

Of course, as soon as I'm asked to contribute a package to Emacs proper I'll
gladly get right and my `issues' with the current header conventions will most
likely disappear. ;)

</pre>

-- [[mon_key]]

----
CategoryHomepage
