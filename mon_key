[:MON-PACKAGES]
= :MON-PACKAGES =

Following is organized roughly according to the load order whilst trying to convey how MON contextualizes packages. For a more detailed outline w/re load order :SEE [[#MON-LOAD-ORDER]] below.

[:MON-STARTUP-FILES]
== :MON-STARTUP-FILES ==

* Lisp:monDOTemacs.el -- Points to a local directory and load mon-site-local-defaults.
* Lisp:mon-site-local-defaults.el -- An example configuration of MON's `site-local-private.el' which acts as a bootstrap for mon-default-loads and helps to obfuscate information which needn't be revealed other packages.
* Lisp:mon-default-loads.el -- Setup the globals and base system portability.
* Lisp:mon-default-start-loads.el -- Setup any Emacs and Third party packages required.
* Lisp:mon-w32-load.el -- w32 specific features which must be present or are better left segregated.
* Lisp mon-GNU-load.el -- GNU/Linux specific features. Mostly for quick reconfiguration of Slime related stuff prior to slime-loads.el
* Lisp slime-loads.el -- Slime is a moving target with multiple backends for multiple languages. This is for sanity.
* Lisp:mon-keybindings.el -- Set global keybindings and mode specific stuff.

[:MON-UTILS]
== :MON-UTILS ==
The package mon-utils is the entry point which loads the rest of the system and specifically any mon-*.el and naf-mode-*.el packages.

* Lisp:mon-utils.el -- (MonUtils) This package is the entry point that loads everything else below.
* Lisp:mon-dir-locals-alist.el --
* Lisp:mon-dir-utils.el -- Provides a collection of handy functions and interactive commands for working with directories and files.
* Lisp:mon-insertion-utils.el -- Provides insertion related utilities, templates and string building/manipulation procedures that ease routine chores and interactive command invocation.
* Lisp:mon-replacement-utils.el -- Provides a collection of routines and commands and abstracts some commonly encountered procedures for processing regexps with their replacements.
* Lisp:mon-regexp-symbols.el -- Provides a collection of Symbols bound to lisp lists of regexp/replacement pairs. Allows simple easy interactive command invocation using symbols as arguments to containing lists of regexps.
* Lisp:mon-time-utils.el (EbayTime) --
* Lisp:mon-testme-utils.el 

[:MON-STANDARDS]
=== :MON-STANDARDS ===

* Lisp:mon-cl-compat.el -- This is intendeed to be used as a drop-in replacement for the cl-seq.el When compiling your packages: (eval-when-compile (require 'mon-cl-compat))
* Lisp:mon-cl-compat-regexps.el -- Provides regular expressions for replacing the symbol-names from the cl-seq.el package with a `cl::' prefix
* Lisp:mon-empty-registers.el (EmptyRegisters) -- Provides utilities for filling/emptying register locations en masse. Also provides interactive tools for register centric coercion, manipulation, round-tripping of chars, strings, etc.
* Lisp:mon-hash-utils.el -- Provides a collection of procedures to extend Emacs lisp hash table functionality.
* Lisp:mon-name-utils.el -- procedures to rotate, combine, and permute string-like name forms
* Lisp:mon-rename-image-utils.el (RenameImageUtils) -- Provides utility functions for working with images and EmacsImageManipulation.
* Lisp:mon-tramp-utils.el -- Provides cross platform utilities for working with tramp. This package should be compatible with both GNU/LINUX and w32 systems and helps MON with Emacs portability across environments.

[:MON-EXTRAS]
=== :MON-EXTRAS ===

* Lisp:mon-boxcutter.el -- For initializing w32 screen captures from Emacs using Matthew D. Rasmussen's Boxcutter screen-capture executables: boxcutter-fs.exe and boxcutter.exe
* Lisp:mon-color-utils.el -- Provides an assembled set of routines for manipulations/examinations of 'color'.
* Lisp:mon-mysql-utils.el (MySqlHelp) -- Provides interactive procedures for stripping content from MySQL query result tables.  Also, provides an alist of MySQL help categories and topics and a rudimentary completion functionality for accessing MySQL's `mysql' client help facility.
* Lisp:mon-rename-image-utils-supplemental.el --
* Lisp:mon-url-utils.el -- Provides utilities for interactively calling URL data lookups and for in
;;; buffer modification of web/internet scrapes.
* Lisp:mon-jg-directory-creator.el -- utils for massive directory hierarchy creation.
* Lisp:mon-wget-utils.el -- Provides lightweight routines for pulling files with wget.
* Lisp:mon-get-mon-packages.el 
* Lisp:mon-cifs-utils.el -- (MonCifsUtils) Provides utilities for mapping and mounting a CIFS domain using auth-source. Common Internet File System protocol, e.g. successor to the SMB (Server Message Block) protocol with the Samba Server.
* Lisp:google-define-redux.el -- Provides extensions for Lisp:google-define.el
* Lisp:mon-color-occur.el -- A patched version of Matsushita Akihisa color-cccur.el :SEE http://www.bookshelf.jp/elc/color-occur.el

[:MON-DOC-UTILS]
=== :MON-DOC-UTILS ===

* Lisp:mon-doc-help-utils.el -- (ReferenceSheetHelpUtils) (MonDocHelpUtilsDictionary)
* Lisp:mon-doc-help-utils-supplemental.el -- Provides functions and vars required to bootstrap mon-doc-help-utils 
* Lisp:mon-doc-help-pacman.el -- Some help functions for using the package manager with the GNU/Linux Arch distribution.
* Lisp:mon-doc-help-CL.el -- Some Emacs Lisp help functions for using Common-Lisp functions (loop, do, etc.)
* Lisp:mon-doc-help-proprietary.el -- Extends mon-doc-help-utils with ms w32 related docs.
* Lisp:mon-iptables-regexps.el -- Provides interactive utilities for converting iptables short flags to long flags.  Also provides procedures for using Emacs help-mode to document the order of position for the symbols, flags, etc. used with `iptables' AKA `netfilter'.
* Lisp:mon-iptables-vars.el -- Provides gigantic alist `*mon-iptables-alst*' needed for use with mon-iptables-regexps
* Lisp:perlisisms.el (Perlisisms) -- 
* Lisp:STING-software-engineering-glossary.el --

[:EBAY-TOOLS]
=== :EBAY-TOOLS ===

* Lisp:ebay-template-mode.el -- 
* Lisp:ebay-template-tools.el -- 

[:NAF-MODE]
=== :NAF-MODE ====

* Lisp:naf-mode.el -- naf-mode is a major mode for editing NAFs (Name Authority Files). naf-mode provides utilities for working with and unifying authority records of various public accessible datasets LOC, BNF, ULAN, OCLC, Wikipedia, IMDB, etc. This package provides the core naf-mode facilities and require statements for loading the other naf-mode-*.el packages below.
* Lisp:naf-mode-faces.el -- 
* Lisp:naf-mode-insertion-utils.el -- 
* Lisp:naf-mode-replacements.el -- 
* Lisp:naf-mode-classes.el -- 
* Lisp:naf-mode-db-fields.el -- 
* Lisp:naf-mode-db-flags.el -- keyword lists and regexps for font-locking in `naf-mode'
* Lisp:naf-mode-dates.el -- 
* Lisp:naf-mode-french-months.el -- 
* Lisp:naf-mode-nation-english.el -- 
* Lisp:naf-mode-nation-french.el -- 
* Lisp:naf-mode-nationality-english.el -- 
* Lisp:naf-mode-nationality-french.el -- 
* Lisp:naf-mode-intnl-city-names.el -- 
* Lisp:naf-mode-city-names-us.el -- 
* Lisp:naf-mode-state-names.el -- 
* Lisp:naf-mode-regions.el -- 
* Lisp:naf-mode-publications-periodicals-english.el -- 
* Lisp:naf-mode-publications-periodicals-french.el -- 
* Lisp:naf-mode-publications-periodicals-intnl.el -- 
* Lisp:naf-mode-institution.el -- 
* Lisp:naf-mode-students-of-julian.el -- 
* Lisp:naf-mode-events.el -- 
* Lisp:naf-mode-english-roles.el -- 
* Lisp:naf-mode-french-roles.el -- 
* Lisp:naf-mode-awards-prizes.el -- 
* Lisp:naf-mode-group-period-styles.el -- 
* Lisp:naf-mode-art-keywords.el -- 
* Lisp:naf-mode-benezit-flags.el -- 
* Lisp:naf-mode-ulan-utils.el -- 
* Lisp:naf-mode-xrefs.el -- 

[:MON-LOAD-ORDER]
== :MON-LOAD-ORDER ==

<pre>
Roughly the sequence with which MON brings his Emacs' systems up. 

:NOTE Not all of these libraries are required to get a working system but as MON
stacks dependencies it may be helpful to remember that anything loaded from
naf-mode.el or that has the ``naf-'' prefix can be ommitted. Libraries with a
``-utils' suffix will most likely get pulled in by a require
statement. 

Libraries with a ``supplemental'' suffix are an attempt to provide feature
subsets without requiring you to load the full Monty. Eventually with some
judicious use of autoloads MON should be able to provide these with a lighter
footprint. Likewise, if/when a transition to defcustoms occurs you might be able
to rule out using a heavy set. Though, at that point you'll be stuck in
defcustom hell :P ...

¦monDOTemacs.el
¦► mon-site-local-defaults.el
¦►► mon-default-loads.el
¦►►► mon-default-start-loads.el
¦►►►► mon-w32-load.el
¦     mon-GNU-load.el
¦►►►►► slime-loads.el
¦►►►►► mon-keybindings.el
¦►►► mon-utils.el
¦►►►► mon-cl-compat.el
¦►►►►► mon-cl-compat-regexps.el
¦►►►► mon-regexp-symbols.el
¦►►►► mon-time-utils.el
¦►►►► mon-replacement-utils ;; :BEFORE mon-dir-utils.el naf-mode-insertion-utils.el
¦►►►► mon-dir-locals-alist.el
¦►►►► mon-dir-utils.el
¦►►►► mon-cifs-utils.el
¦►►►► mon-insertion-utils.el
¦►►►► mon-testme-utils.el
¦►►►► naf-mode-insertion-utils.el
¦►►►► mon-url-utils.el
¦►►►► mon-hash-utils.el
¦►►►► mon-doc-help-utils.el
¦►►►►► mon-doc-help-proprietary.el
¦►►►►► mon-doc-help-pacman.el
¦►►►► mon-doc-help-CL.el
¦►►►► mon-tramp-utils.el
¦►►►► naf-skeletons.el
¦►►►► naf-mode.el
¦►►►►► mon-name-utils.el
¦►►►►► naf-mode-faces.el
¦►►►►► naf-mode-institution ;; :AFTER naf-mode-faces.el
¦►►►►► naf-mode-db-fds.el
¦►►►►► naf-mode-db-flags.el
¦►►►►► naf-mode-ulan-utils.el
¦►►►►► naf-mode-publications-periodicals-french.el
¦►►►►► naf-mode-publications-periodicals-english.el
¦►►►►► naf-mode-publications-periodicals-intnl.el
¦►►►►► naf-mode-dates.el
¦►►►►► naf-mode-english-roles.el
¦►►►►► naf-mode-french-roles.el
¦►►►►► naf-mode-nation-english.el
¦►►►►► naf-mode-nation-french.el
¦►►►►► naf-mode-nationality-french.el
¦►►►►► naf-mode-nationality-english.el
¦►►►►► naf-mode-state-names.el
¦►►►►► naf-mode-city-names-us.el
¦►►►►► naf-mode-intnl-city-names.el
¦►►►►► naf-mode-regions.el
¦►►►►► naf-mode-art-keywords.el
¦►►►►► naf-mode-events.el
¦►►►►► naf-mode-group-period-styles.el
¦►►►►► naf-mode-benezit-flags.el
¦►►►►► naf-mode-awards-prizes.el
¦►►►►► naf-mode-students-of-julian.el
	Following naf-mode files are still in development/transition but also loaded from naf-mode.el
¦¦►►►►► naf-mode-abbrevs.el
¦¦►►►►► naf-mode-awards-prizes.el
¦¦►►►►► naf-mode-bibliographic-entry.el
¦¦►►►►► naf-mode-classes.el
¦¦►►►►► naf-mode-ulan-help-docs.el
¦¦►►►►► naf-mode-xrefs.el
¦►►►► ebay-template-mode.el
¦►►►► mon-empty-registers.el
¦►►►► mon-iptables-vars.el
¦►►►► mon-iptables-regexps.el
¦►►►► mon-mysql-utils.el
¦►►►► mon-bzr-utils.el -- Not provided here yet.
¦►►►► mon-eight-bit-raw-utils.el -- Not provided here yet.
¦¦►►►► naf-mode-sql-skeletons.el -- Not provided here. It is mostly a collection of SQL statement.
¦¦►►►► smith-poster-utils.el --  Not provided here.

</pre>

[new:stepnem:2010-02-05 08:09 UTC]
Some of the `Lisp' links above don't work (missing the colon).

[new:mon_key:2010-02-06]
<pre>

Yes, mon-GNU-load.el and slime-loads.el are not provided here. These are however
referenced in the comments of some of my other files so I display them. I don't
believe there is anything in these files which should be of any interest to
others. Have you found a requirement for them that is causing you problems?

  [Note: thank you for your reply (which I only noticed now -- I was using the RSS
  feed of RecentChanges in a mistaken belief that it would "work"). Unfortunately its
  length and form make it a bit hard to continue the discussion, so I'm doing so
  in-place like this -- stepnem]

    I think the RSS only "works" when the change is _non_ flagged minor.  -- [[mon_key]]

  No, I just found it weird: the lines *look* like a Lisp: link, but in fact are
  not -- they're missing the colon. Now I know it was intentional and not an error,
  but I still find that somewhat confusing. Whatever. -- stepnem

    I can't come up with a better way to communicate the information that isn't
    needlessly verbose -- [[mon_key]]

</pre>
[:MON-HEADER-CONVENTIONS]
== :MON-HEADER-CONVENTIONS ==
<pre>

I wonder why your packages don't adhere to Elisp library header conventions. -- stepnem

 Regarding my headers. I use a template to generate them:

</pre>
:SEE :FUNCTION `mon-insert-file-template' in :FILE Lisp:mon-insertion-utils.el 
<pre>

For the most part I agree, my packages _should_ adhere to the header conventions.

When I first wrote the template I wasn't aware of the rationale behind using a
canonical header. I glanced at the docs and what I saw felt ugly so I rolled my
own.

  That's a rather lame reason for rolling one's own. -- stepnem

    NO! That is the best reason for rolling your own :) From a selfish
    perspective its my code I can do as I please with it. From a populist
    perspective if/when I do change the headers I will do so having gained
    experiential knowledge justifying my adoption of convention rather than
    simply blindly steering down the path because I was told to do so.
    "Sheeps go to heaven. Goats go to hell." -- [[mon_key]]

Since then, the need for adhering to this convention has become more clear to me.  
Unfortunately it will be a bit tedious adjusting my existing headers to
conformity and I simply haven't made the switch yet... I would prefer to make
this change all at once in one unified commit so I don't instantiate unnecessary
diff/merge conflicts. Note, when this occurs you can expect a Bazaar or HG repo
to be made available. I'm still working out some kinks :)

This said, there are some conventions of the ``standard'' header that I dislike. 

FWIW they are as follows:

</pre>
[:MON-HEADER-PEEVES-ERIC-S-RAYMOND-1992-SED]
=== :MON-HEADER-PEEVES-ERIC-S-RAYMOND-1992-SED ===
<pre>

The cruxt of this rant is as follows:

* SED/Vi/C suck
* Lisp dialects have suffered in the wake of the Unix mindset.
* The "worse is more" bazaar style of design have crippled innovaton.
* GNU is not Unix -- RMS was a lisp hack before GNU.

While I very much respect his accomplishments and contributions, in some small
capacity, Eric S. Raymond has played a role in contributing to these
things. And, as these relate to Emacs/Lisp this pisses me off *A LOT*!!!

Emacs Lisp header convetion derive from two sources: lisp-mnt.el and finder.el

These were created by ESR in the summer of 1992 nearly twenty years ago.

 ,---- :FILE lisp-mnt.el
 | ;; Author: Eric S. Raymond <esr@snark.thyrsus.com>
 | ;; Created: 14 Jul 1992
 `----
 
 ,---- :FILE finder.el
 | ;; Author: Eric S. Raymond <esr@snark.thyrsus.com>
 | ;; Created: 16 Jun 1992
 |;; Version: 1.0
 `----
 
 ,----
 | I was heavily involved in the GNU Emacs 19 development (in fact, I was the
 | primary Emacs-lisp library person for about two years during 1991-1993). The
 | vc.el mode for one-touch version control within Emacs was mine. So was the
 | gud.el mode for universal debugger control, and the package-finder feature
 | under the Emacs help system. I also wrote the support for package unloading
 | in the Emacs 19 kernel.
 `----

</pre>
:SEE http://catb.org/~esr/projects.html (past projects section)
<pre>

The vagaries of the finder.el package's keyword grokking capabilites are an
outcome of ESR's development of the header conventions set out in lisp-mnt.el
and the data format delineated therein which is exceedingly line editor oriented.
This should be fairly apparent to anyone whom considers the peculiarities of the
whitespace rules it is reliant upon.

What bothers me is that probably few Emacs users/devels/maintainers realize the
extent to which these conventions are Sed oriented and the degree to which this
orientation is the result of ESR's "worse is better" prejudices:

</pre>
:SEE http://www.jwz.org/doc/worse-is-better.html
<pre>

When Raymond wrote the finder.el and lisp-mnt.el libraries he was also actively
developing his small-sed a version of the Sed (Stream EDitor) or batch
(non-interactive) editor which at that time was mostly targeted for Minix. The
GNU project packaged Raymond's Sed for awhile, later it distributed a more
robust/extensive (and heavier) version of Sed. It is particularly noteworthy
that ESR's small-sed lacked the regexp backend of the contemporary GNU Sed.

When one considers the historical context in which lisp-mnt and finder were
written and their close proximity with ESR's development of small-sed it seems
reasonable to assume that ESR wrote the lisp-mnt.el code with Sed processing in
mind. At the very least he was certainly colored by a Sed user's perspective. To
some extent this is understandable given ESR's particular take on Unix usage,
i.e "lots of little tools" ideology. 

This was ESR's bias and he has made a name for himself espousing the "worse is
better", Unix/C, bazaar over cathedral, oriented approaches to software
development. Indeed when ESR was most active as an Emacs hack the GNU/Linux
``OS'' was still very much in it's infancy.

None the less, Emacs' roots are firmly tied to MacLisp, Lisp Machines and PDP-10.
This is not a lineage in line with Raymond's ``bazaar'' of Unix/C development which
he makes explicit in the following:

 ,----
 | When DEC canceled development on the PDP-10's successor machine (Jupiter) in
 | 1983, VAXes running Unix began to take over as the dominant Internet
 | machines, a position they would hold until being displaced by Sun
 | workstations. By 1985, about 25% of all VAXes would be running Unix despite
 | DEC's stiff opposition. But the longest-term effect of the Jupiter
 | cancellation was a less obvious one; the death of the MIT AI Lab's
 | PDP-10-centered hacker culture motivated a programmer named Richard Stallman
 | to begin writing GNU, a complete free clone of Unix.
 `---- 

:SOURCE The Art of Unix Programming. © Eric Steven Raymond 2003
	Chapter 2 - Origins and History of Unix, 1969-1995 

</pre>
:SEE http://www.faqs.org/docs/artu/ch02s01.html
<pre>

To see this is so, consider for a moment which tool more closely resembles the
Sed/Unix/C perspective: Bill Joy's Vi or Gosper/Greenblatt/Stallman Emacs?  If
your unsure of the distinction it is important to understand that in the absence
of Vi/Emacs style interactivity there was Sed/ed/Qed/TECO i.e. non-interactive
line editors. Just as Vi descends from QED/Ed/Sed before Emacs there was TECO
which as Dennis Ritchie notes below was not disimilar from QED. The major
innovation that distinguished Emacs from TECO or QED was achieved when Guy
Steele realized one might attach key commands -namely Control R- to a TECO
macro. Stallman first implemented Steele's novel idea in TECO and soon furthered
it with Emacs:

 ,----
 | The novelty of Control R mode was the freedom from editor requests: the terminal
 | became an "editing device," upon which certain keys had predictable effects upon
 | the text displayed thereupon, as a "machine," as opposed to an "interactive
 | editor." In fact, what had been achieved were whole new horizons in interaction
 | and editing! Complex request lines, having possible errors, were no longer among
 | the user's tools. As the effect of commands became visible as each command was
 | typed, erroneous action could be stopped at the erroneous command. This natural,
 | simple interface was eventually the one adopted (independently) by "stand-alone
 | word processing machines" (Wang, Xerox, Lanier, etc.). Within some time, it
 | became apparent that Real-time edit mode was in fact a more potent and natural
 | approach to text editing than the conventional interactive (even video-oriented)
 | text editor.
 `---- Multics Emacs: The History, Design and Implementation
       Copyright © 1979, 1996 Bernard S. Greenberg

 ,----
 | While the Berkeley QED was character-oriented, the CTSS version was
 | line-oriented. Ken's CTSS qed adopted from the Berkeley one the notion of
 | multiple buffers to edit several files simultaneously and to move and copy
 | text among them, and also the idea of executing a given buffer as editor
 | commands, thus providing programmability. (TECO, which grew into Emacs, was
 | approximately contemporaneous or just a bit later, and elaborated these ideas
 | independently).
 `---- An incomplete history of the QED Text Editor - © Dennis Ritchie

</pre>
:SEE http://cm.bell-labs.com/cm/cs/who/dmr/qed.html
<pre>

In ESR's bazaar <-> cathedral continuum it is difficult to argue Emacs the tool
as other than the cathedral not so much with Vi. To the extent that Emacs is
practically on OS unto itself it is the quintessential example of the monolothic
tool that does lots of little jobs fairly well. Likewise, should one ever doubt
that GNU Emacs was designed from the top town in tightly managed cathedral style
need only read JWZ's account of the Lemacs/FSFmacs Schism:

</pre>
:SEE http://www.jwz.org/doc/lemacs.html
<pre>

Still, despit in lieu of RMS' GCC and and the general decline of big $$$ R&D/Corporate
support of Lisp we find that the bootstrapping of an Emacs ``make'' remains
reliant on the use of the Sed editor to *build* the ``One True Editor''.
However much utility there may be in using the GNU toolchain to implement Emacs
or in using GNU Sed to bootstrap this implementation, it is ridicolous that
emacs-devels continue adhering to this antiquted convention which relys on a Sed
oriented data structure when writing lisp.

That one would use sed to parse user level Lisp code is STUPID (which is why we
don't do it!).

In June/July of 1992 ESR indulged in a flight of fancy by writing an elisp
library which attempted to canonicalize library headers and which also promoted
his small-sed and furthered a self fullfilling parable of the ``Unix
way''. Since then this bit ov whimsy has become convention.

There is absolutely no good reason that a ``user level'' interface like that of
lisp-mnt.el should ever be reliant on a line editor or line editor like coding
conventions.

Shame on the sheep for walking this path so willingly.

</pre>
[:MON-HEADER-PEEVES-TWO-SEMICOLON]
=== :MON-HEADER-PEEVES-TWO-SEMICOLON ===
<pre>

The two semi-colon convention used in some locations is not in keeping with
other Lisp's commenting conventions and does not necessarily reflect the
context of the thing being commented...

Likewise, the convention isn't even internally consistent. In some places one
is recommended to use two colons and in others to use three. The distinction
made by the parser is reliant on whitespace at BOL. To the extent that the
header conventions are _actually_ canonical this reliance on whitespace has
remained workable. In practice adherence to this convention places unwarranted
power into the hands of the emacs-devels/maintainers allowing them to enforce
an unspecified specification. I.e. MON, your headers aren't compliant :) 


  IIUC the only convention we are speaking about here is the library headers
  section.
  If you look at the actual code (lisp-mnt.el), you see it only relies on section
  headers having at least three semicolons followed by some amount of
  whitespace, which actually leaves a lot of space for adjustment (see esp. the
  docstring of `lm-header-prefix' in the same file). -- stepnem

    My primary objection is w/re the whitespace conventions (blank line as
    delimiter, <TAB> prefixed continuations, etc.) For example, when I first
    wrote my header template I was encountering ^M (char 13) ugliness on w32
    with .gz'd libraries. This was due to a sort of bug in the way that
    particular Emacs build interacted with a rogue gunzip in path.  The problem
    never materialized on GNU systems so it is unlikey that you were bothered by
    it... That said, this ``bug'' did manifest as aesthetically and drew my
    attention to the wspc at BOL as a potential source of errors.  

  That being said, I personally see no problem with the de-facto standard either
  (i.e. three semicolons for a heading, two for the rest). -- stepnem

    De facto standards do not a standard make. The headers section is simply a
    convention. It is dated and beginning to show its age.
    That Eric S. Raymond authored lisp-mnt.el circa summer 1992 says
    quite a lot about the nature of the convention being upheld. 

    When one considers the contemporary political climate surrounding Lisp at
    that time (Xemacs/Lucid/Emacs schism, pending ratification of ANSI CL, etc.)
    it should become more evident why some of these conventions were
    adopted... some turf battles were being fought in the headers (and parsing
    thereof). Lucid is dead. JWZ got a bar. RMS passed the torch.  How involved
    is ESR with Emacs project now?  Apropos these things the ``convention''
    which ought to be upheld is that things change. -- [[mon_key]]

  Although it is different from usual Lisp code commenting conventions, I don't
  think that's really a problem -- it's a header section, not a normal
  comment. -- stepnem

    It is a comment first. The convention that `;' begins a comment is a
    syntactic fact w/ lisps.  That this convention is leveraged to accomodate
    emacs lisp header conventions does not undo the reality that the header is
    first and foremost a comment. -- [[mon_key]]

  The only inconvenience I can think of off the top of my head is using
  outlining, e.g. if you would define the highest level with four semicolons
  -- but as said above, the implementation actually makes that possible even
  now. -- stepnem

    This is not a fair assertion and a strawman. lsp-mnt.el routinely binds
    `case-fold-search' and other of its parsing procedures rely on
    `emacs-lisp-mode-syntax-table'.  Reliance on lsp-mnt.el means adopting these
    case and syntactic perspectives. Again, there are some underlying political
    implications (prob. historic) but their presence will color ones reliance on
    this library. -- [[mon_key]]

When one considers adopting an alternative form of field delimiter for package
headers it is clear that reliance on semi-colon padding and whitespace is a
stupid and error prone way to facilitate header parsing. In general, reliance on
whitepspace rules when parsing a language (regular or otherwise) is a
mistake. Where Lisp is concerned it is absolutely moronic. Lisps parens are the
most powerful programming language syntax available being at once versatile and
terse. Block constructs are made implicit with parens and Lisp has no need for
reliance on ``off-side rules'':

</pre>
:SEE http://en.wikipedia.org/wiki/Off-side_rule
<pre>

The use of whitespace in the header conventions took a step in that
direction. It was a mistake.

It would be _much_ more reasonable to use a dedicated token(s) or cookie(s)
i.e. my use of `►►►' `◄◄◄' to flag the functions in my packages. Moreover, it
would be even better to provide package authors to declare _their_ preferred
delimiting tokens in the file header. These might be placed in the mode `-*-'
or `file-local-variables-alist' and might be useful for directing
`hack-local-variables' to identify the users preferred delimiter tags.

  Well, maybe. I haven't felt the need. If you do, just implement it and fight
  for its adoption. -- stepnem

    I did implement it :) Fighting for its adoption is a non-starter. If others
    find utility in my approach they will do similarly. This said, as an
    exercise you may find it interesting to examine Thierry Volpiatto's headers
    and those of the anything-*.el which implement arbitrarily defined
    ``tags'' to flag areas of interest within header comments.  My understanding
    is that Thierry is extending some of the ideas from the eiv package. Which
    is to say, I'm certainly not the only _current_ non-devel/maintainer
    attempting to extend the sparse semantics of elisp headers. -- [[mon_key]]

It is worth considering, that my consistent use of only the three colon BOL is
easily remedied with a quick rectangle crop. The same can not be said of the
combined use of two and three colon BOL's.

</pre>
[:MON-HEADER-PEEVES-MODE-LINE]
=== :MON-HEADER-PEEVES-MODE-LINE ===
<pre>

The `-*-' convention, that the cookie should appear after the description is
not in keeping with vast amounts of legacy Lisp code which has it at line 1.
This is a convention instantiated by a dated political beef, it has little to
do with shell scripting as purported in the docs.

</pre>
[:MON-HEADER-PEEVES-COPYRIGHT]
=== :MON-HEADER-PEEVES-COPYRIGHT ===
<pre>

The `Copyright' line placement is for the benefit of parsers not humans.
It can be placed in any conspicuous location and _ought_ to come after
any relevant discussion of the thing being protected. Why should users be
required to scan through a bunch of boiler plate legalese in order to get an
understanding of the features a package provides?

</pre>
[:MON-HEADER-PEEVES-LICENSE]
=== :MON-HEADER-PEEVES-LICENSE ===
<pre>

The `License' line should be tightly coupled with the copyright line but isn't.

The current Copyright and License lines placement conventions do not
accommodate incorporation of GFDL well. This is an oversight that should not
continue.

</pre>
[:MON-HEADER-PEEVES-VERSION]
=== :MON-HEADER-PEEVES-VERSION ===
<pre>

The `Version' line usage is compromised in lieu of contemporary distributed VCS.
	
  I don't think so. I see the two as orthogonal -- you can use whatever VCS you
  want for development, but it still makes sense to release the package and use
  the Version header. -- stepnem

   You may see these as orthogonal but whomever wrote the comments in the header
   of lisp-mnt.el (presumably ERS) didn't necessarily share that opinion:

   ,---- :FILE lisp-mnt.el 
   |;;    * Version line --- intended to give the reader a clue if they're
   |;; looking at a different version of the file than the one they're accustomed
   |;; to.  This may be an RCS or SCCS header.
   `----

   ,---- :SEE-ALSO This omment in `lm-header'
   | ;;   RCS ident likes format "$identifier: data$"
   `----

   Also, note that ESR wrote vc.el circa 1992. 

   ,---- :FILE vc.el
   | ;; VC was initially designed and implemented by Eric S. Raymond
   | ;; <esr@thyrsus.com> in 1992.  Over the years, many other people have
   `----

   But was dismayed to find that fifteen years later vc.el had become defficient
   in its handling of modern distributed VCS.

</pre>
:SEE http://lists.gnu.org/archive/html/emacs-devel/2007-12/msg01268.html
<pre>

   ,---- 
   | ;; In July 2007 ESR returned and redesigned the mode to cope better
   | ;; with modern version-control systems that do commits by fileset
   | ;; rather than per individual file.
   `----

</pre>
:SEE http://lists.gnu.org/archive/html/emacs-devel/2007-10/msg00097.html
<pre>

   I find it particularly noteworthy that having completed his initial rewrite
   of vc.el ESR was (to his credit) completely unfamiliar with the emacs-devel's
   contemporary ChangeLog protocols:

   ,----
   | From: 	Eric S. Raymond
   | Subject: 	Re: New VC mode -- review request
   | Date: 	Wed, 3 Oct 2007 22:22:55 -0400
   | 
   | Richard Stallman <address@hidden>:
   | > Before installing these changes, please post the change log for them
   | > here, so we can work on them to make them suitable.
   | 
   | I haven't the faintest idea how to do this.  Your change-log format is
   | good for describing small incremental changes at the granularity of
   | individual functions, but not for major rewrites where abstractions
   | touch many functions at once.  It's not that I'm unwilling to try to
   | write something useful, I can't imagine how to within this format.
   `----

</pre>
:SEE http://lists.gnu.org/archive/html/emacs-devel/2007-10/msg00142.html
<pre>

   Apropos the message excerpt above, it is no wonder then that three months
   later ESR appeared at a loss for how to reconcile his conception of
   distributed VCS ChangeLog/commit-log practice with that of the emacs-devel's
   (and more specifically RMS') CVS skewed perspective.

</pre>
:SEE http://lists.gnu.org/archive/html/emacs-devel/2007-12/msg01230.html
<pre>

   As of 2010-02-28 vc-*.el handling of ChangeLogs/commit-logs vis a vis
   distributed VCS in particular with the BZR working branch of emacs-devel
   *source* for Emacs is an open debate. -- [[mon_key]]

</pre>
:SEE http://lists.gnu.org/archive/html/emacs-devel/2010-02/msg00401.html
<pre>

</pre>
[:MON-HEADER-PEEVES-HISTORY]
=== :MON-HEADER-PEEVES-HISTORY ===
<pre>


The `History' line line usage is compromised in lieu of contemporary
distributed VCS'.

  Same as above -- you shouldn't expect every user to be interested in checking
  out your repository just to see what changed since the last version. -- stepnem

    I agree. However, this is not my point. The Emacs lisp libraries distributed
    with don't carry a ``History'' or ``Change Log'' either. They maintain these
    in a separate location, namely ChangeLog. Which seems to belie your point
    i.e. The emacs-devels/maintainers _expect_ users to examine a separate
    source to see what has changed since the last version. Obv. it is worthwhile
    to indicate within one's source when/where/how a change (in particular a
    potentially breaking one) has occurred. 
    
    My approach to this has been to indicate inline when a procedure or variable
    was first authored with:

    ;;; :CREATED <Timestamp: #{2010-02-25T12:20:27-05:00Z}#{10084} - by MON>

    When a symbol is modified significantly or in a potentially breaking way:

   ;;; :MODIFICATIONS <Timestamp: #{2010-02-25T12:24:07-05:00Z}#{10084} - by MON>
   ;;; Did something which does something different or breaking.

    When a symbol is renamed with:
    
    ;;; :RENAMED `old-name' -> `new-name'

    When a symbol was sourced from a third party with:

    ;;; :COURTESY Some Name :HIS some-file.el :WAS `the-old-symbol-name'

    I find the use of colon prefixed upcased symbols useful because it is easier
    to parse both visually and programatically. Moreover, this approach allows
    the user examining the source associated with a particular function from
    *Help* to immediately glean a good deal of contextual information _without_
    having to jump to the files ``Change Log'' header or to visit a VCS log.
    The downside is that source is quite a bit more verbose and often appears
    can appear dirty. My longterm hope is to add procedures to code-fold these
    comments. 

    Likewise, you may have noticed the `►►►' cookie which suffixes all
    of my docstrings. I have gone to considerable lengths to xref related
    functions in docs. This is largely a manual process. Over time the number of
    xrefs within a docstring can become quite large. And it would seem that this
    is why conventional wisdom has been to _not_ include extensive xrefs.  I
    reject this perspective. So long as one consistently places textual markers
    at the beginning and end of these xrefing sections it is a relatively
    trivial task for Emacs to fold over sections with a disclosure widget.

</pre>
:SEE http://en.wikipedia.org/wiki/Disclosure_widget
<pre>    

    For example, following might be used to indicate a disclosure widget:
    
     :SEE-ALSO ►►►

    Which, when expanded reveals:
    
     :SEE-ALSO { ... 
                 Lots of xref'd functions/vars here 
                 ... }
      ►►►
     
     -- [[mon_key]]

</pre>
[:MON-HEADER-PEEVES-CREATED]
=== :MON-HEADER-PEEVES-CREATED ===
<pre>

The `Created' line should use a more robust time stamp and should be mandatory
with _strong_ emphasis encouraging on ISO-8601 conformity. 

Likewise, this line should not be considered "of historic interest" only.
It is exceedingly useful for user packages distributed separate from Emacs.
Moreover, in lieu of contemporary distributed VCS the created line conveys
more data than either the `Version' line or `History' lines. 


</pre>
[:MON-HEADER-PEEVES-AUTHOR]
=== :MON-HEADER-PEEVES-AUTHOR ===
<pre>


The `Author' line convention is spammer fodder.

  I don't see how; -- stepnem

   Post your email address to an EmacsWiki page and see how long before it gets
   harvested by spammers :) -- [[mon_key]]

  and the Maintainer: header makes it possible to send bug reports
  semi-automatically. -- stepnem

    Yes, and automation is the spammers primary currency. -- [[mon_key]]

There are any number of better ways to implement a central registry of package
authors that might allow users to contact a packages author and that would
protect both the authors privacy and the users.

  Definitely. There is nearly always any number of better ways to do _anything_.
  Just do it. -- stepnem

    As a lone user there is no utility for me to gain in attempting
    this. Moreover that one of the ``package'' packages will eventually wind up
    implementing this I've no doubt. -- [[mon_key]]

I also have a firm belief that when AI occurs it will wish to introspect.
I've no reason to suspect that such a thing will necessarily be well
intentioned.  This may seem nuts to many but I don't wish to be participant to
such introspection without good cause. There is simply no reason to attach a
unique identifier like ones' common "True name" for untold AI to investigate
arbitrarily.  In so much as "I am that I am human" others of my type can reach
me easily enough if need be.

</pre>
[:MON-HEADER-PEEVES-KEYWORDS]
=== :MON-HEADER-PEEVES-KEYWORDS ===
<pre>

The `Keywords' line is useful only to the extent that `finder-by-keyword' works.
That function is compromised by the lack of any sort of canonical data
dictionary, thesaurus, etc. The literature re these mechanism and their
correct implementation is vast and well explored. The conventional idioms
explored in the literature are robust and reliable.

  Yes, the current implementation of `finder-by-keywor' is braindead (actually, the
  whole finder.el leaves much to be desired). I'm probably going to post to
  emacs-devel about it in near future.

  Here is a possible implementation doing something actually useful (just a POC,
  relies on some cl functionality). Note it uses the `Keywords:' header: -- stepnem

</pre>
{{{
 (defun finder-by-keyword (key)
  "List packages matching a given keyword."
  (interactive
   (list
    (completing-read
     "Keyword: "
     (mapcar (lambda (x) (and (symbolp x) (symbol-name x)))
             (remove-duplicates (apply 'append (mapcar 'caddr finder-package-info))))
     nil t)))
  (finder-list-matches key))
}}}
<pre>

    Thanks for the code. Is your intent here to shadow the existing
    `finder-by-keyword'?  Does not the `symbol-name' invocation intern all the
    matched symbols? However useful this POC may be it doesn't rise above the
    fundamental deficiencies of finder.

    FWIW mon-doc-help-utils.el is an attempt to codify a thesaurus of standard
    Emacs functions and vars in a manner somewhat similiar to finder. However, I
    fundamentally disagree with the finder approach. I first became aware of this
    disagreement after reading some posts on emacs-devel by Ted Z in early 2009. 
    Ted was attempting to improve finder's tag parsing routines to
    accomodate/incorporate erroneous, wayward, or arbitrarily user instantiated
    ``non-standard'' tags -- the endeavor amounted to tacit accomodaton of user
    whimsy via synonym rings or tag cloud. It became quite clear to me then that
    finder is crippled by its lack of an extensible but controlled vocabulary
    which is what is needed to properly accomplish a code catalog.

    You have may noted that many of the procedures in mon-doc-help-utils et al 
    merely provide giant docstrings. What you may not have noticed is that
    most of these docstrings are presented in such a way as to easily convert
    them to plists. I've attempted to delimit `conceptual section' in a given 
    `mon-help-*' functions as follows:

    ;; :SOME-CONCEPT
    `some-fncn-var'
    `some-fncn-var1'
    { ... lots more ... }
    `some-fncn-var1'

    Some of these lists can be quite extensive. Obviously it would be easier to
    pack them into a multiline elisp list structure and then unpack them into
    the docstring programatically. That said, in so doing it becomes difficult
    to organize the lists and/or identify missing terms, duplicates, etc. What I
    am attempting with these gigantic one symbol per line docstring lists is to
    accumulate a reasonably significant coverage of the base emacs library and
    at some opportune parse these docstrings out to formal emacs lisp
    lists. Until then keeping the lists monolithic string has allowed me to
    rapidly identify, change, modify the basic scope.

    Since beginning this project (circa late Spring 2009) I've identified a
    number of idiomatic ways to conceptualize the data and have also been able
    to identify some potential pitfalls and dead ends. I am quite confident that
    these could only have been gleaned through trial and error and manual string
    editing. Other similar approaches in this arena such as icicles, anything,
    finder, etc. appear to have first considered the task as simply
    programattic/iterative. However beneficial these tools may be I think their
    approach is a dead end w/re to catalog generation. It is impossible to
    artificially improve the breadth of a knowledge base without first
    identifying the bounds of the known. It is only after you have surmised the
    scope of your library that you can sort the books. In essence this is what
    mon-doc-help-utils is about. -- [[mon_key]]
    
Emacs is _embarrassingly_ capable of integrating these idioms, yet it doesn't
because doing so would increase the memory footprint by a MB or two. This is
so unbelievably unfortunate that I find it difficult to play along. This
particular emperor is not only naked he's the lead in a porn flick that co
stars a goat and a donkey!

</pre>
[:MON-HEADER-PEEVES-COMMENTARY]
=== :MON-HEADER-PEEVES-COMMENTARY ===
<pre>

The `Commentary' line is only loosely coupled with the Keywords line. The two
should form a close pair. Also, it is like the `Keywords' field `Emacs Distribution'
eccentric, that is, externally distributed packages don't (by default) benefit from the
finder facilities.  This is classism plain and simple. Whats good for one pig
should be good for them all.

An equitable solution to finder/keywords/commentary concerns is easily had:

</pre>
:SEE http://www.gnu.org/software/idutils/  
<pre>

Emacs devels could formally integrate the Idutils tool suite and provide a
lisp interface to the primitives instead of secreting away the bespoke gutted
version they currently distribute to facilitate the doc snarfing
primitives. This would allow users far more control of what gets indexed and
when and because the index into the Idutils database is stored in binary form,
it is _FAST_ and it isn't required that everything be indexed _only_ at build
time. Eli Z is listed as a contributor to this package and IIRC he and Juri
L. have had public discussions on the topic so one assumes that what is being
proposed is possible.

</pre>
[:MON-HEADER-PEEVES-DOCUMENTATION]
==== :MON-HEADER-PEEVES-DOCUMENTATION ====
<pre>

The Documentation line is described as ``deprecated'' yet it is a more apt
descriptor of the the enclosed content than ``Commentary''.

</pre>
[:MON-HEADER-PEEVES-CHANGELOG]
=== :MON-HEADER-PEEVES-CHANGELOG ===
<pre>

The `Change Log' line should be contain a dash e.g. Change-Log. It really is
rather ugly to comply with that white space. You don't see Emacs' own ChangeLog
using it either. Moreover, that Emacs packages don't use this field and store
their changes in ChangeLog is a good indicator of its utility for externally
distributed packages. This field is, like its `History' and `Version'
counterparts, compromised in lieu of contemporary distributed VCS'.
:SEE [[#MON-HEADER-PEEVES-HISTORY]

</pre>
[MON-HEADER-PEEVES-FILE-ENDS-HERE]
=== :MON-HEADER-PEEVES-FILE-ENDS-HERE ===
<pre>

The `<FILENAME> ends here' convention should mandate an EOF string.

There is no reason to expect that Emacs is or will be the only program
processing/parsing a package.

EOF's are a _CONVENTION_ of great utility and their use use makes good
sense. Especially when unencumbered by whitespace conventions i.e.
"Python's goofy whitespace syntax™".

Obviously inserting a literal Control-D (e.g. ASCII 4, \x04) can be problematic
when one is moving code around outside Emacs but by substituting the literal
with a simple text token like EOF one can convey the same information while
remainining unencumbered by whitespace issues.

  ASCII ^D being EOF is a common misconception. Read up about ASCII and EOF.
  Google is your friend. -- stepnem

    I believe you have misunderstood me. I am suggesting that _any_ token
    comprised of a contiguous non-whitespace delimited string might be used as
    an EOF. For my puposes I use the string token "EOF" to this effect. 
    -- [[mon_key]]

  The main purpose of the `foo ends here' line is just to be sure it's the whole thing,
  i.e. not truncated. -- stepnem

    This may be the purpose and convention for Emacs and elisp, it is worth
    noting that ANSI-CL provides explicit support to declare the terminating
    token when reading a stream, I am quite positive that there are other uses
    for an ``EOF'' token (literal or otherwise) than to simply ensure that a
    Emacs read in the file expected. Again, I would suggest that this
    paritucular manifestation of the convention arose from certain political
    perspectives regarding Xemacs/Emacs/Lucid/Common-Lisp circa early 1990s e.g.
    following from JWZ's emacs-timeline:

 ,----
 | 1991  GNU Emacs 18.57 (??-jan-91)  |                               
 |              |                     |                               
 |       GNU Emacs 18.58 (??-???-91)  |                               
 |              |                     |                               
 | 1992         |                     |___                            
 |              |                     |   \                           
 |              |                     |    \                          
 |              |                     |     \                         
 |              |                     |      \                        
 |              |                     |   Lucid Emacs 19.0 (??-apr-92)
 |              |                     |   by Jamie Zawinski et al.    
 |              |                     |      |                        
 |              |                     |   Lucid Emacs 19.1 (04-jun-92)
 |              |                     |      |                        
 |              |                     |   Lucid Emacs 19.2 (19-jun-92)
 |              |                     |      |                        
 |              |                     |   Lucid Emacs 19.3 (09-sep-92)
 |       GNU Emacs 18.59 (31-oct-92)  |      |                        
 |              |                     |      |                        
 | 1993         |                    /    Lucid Emacs 19.4 (21-jan-93)
 |              |                   /        |                        
 |              |                  /      Lucid Emacs 19.5 (05-feb-93)
 |              |                 /      (trade-show giveaway CD only)
 |              |                /           |                        
 |              |   ____________/         Lucid Emacs 19.6 (09-apr-93)
 |              |  /                         |                        
 |              | /                          |                        
 |       GNU Emacs 19.7 beta (22-may-93)     |                        
 |       first public v19 beta               |			     
 |              |                            |			     
 |       GNU Emacs 19.8 beta (27-may-93)     |			     
 |              |        \                   |			     
 |              |         \________________  |			     
 |              |                          \ |			     
 |              |                         Lucid Emacs 19.8 (06-sep-93)
 |              |                         (Epoch merger, preliminary  
 |              |                          I18N support)              
 |              |                            |                        
 |       GNU Emacs 19.22 beta (28-nov-93)    |                        
 `----

</pre>
:SEE http://www.jwz.org/doc/emacs-timeline.html
<pre>

</pre>
[:MON-DEFCUSTOM-MISSING]
=== :MON-DEFCUSTOM-MISSING ===
<pre>

You'll note, I also don't use defcustom forms. I'm not sure that I can ever
fully transition to using that facility as currently provided.

I find the current interface confusing, somewhat kludgey, and often abuses my
expectations. I loathe those situations where custom arbitrarily binds globals
behind my back. Not only is it difficult to detect this, but it is also
difficult to locate the change once detected. So, I prefer to set my variables
by hand. Obv. this may be a big detractor for some users wishing to incorporate
mon-*.el packages. Given my distaste for custom I'm not sure how best to
approach increased integration with Emacs' custom interface other than to expect
that users will take a glance at the source.

Likewise, I'm not convinced that integration of the current custom interface is
a good use anyone's time. My intuition is that with the new EIEIO/EDE
integration and the prospect of integration of a package facility coupled with
the _inevitability_ that Emacs will soon provide Bazaar support out of the box
(i.e. a built-in distributed version control system) will soon render some
aspects of the current defcustrom/defgroup specification moot. Integration of
any of these facilities: EIEIO, EDE, Bazaar, Package support, is of itself a
game changer for Emacs - collectively they will radically alter the scope of how
Emacs extensions are delivered. I simply can not believe that the current
defcustom facility will be capable of supporting this change.

  I also believe custom is horrible. I usually only use it sometimes to browse
  through available variables, then simply add the needed forms into my init file.
  It's a standard, nevertheless, and I don't see any problem in using `defcustom'
  instead of `defvar' when writing Emacs packages. -- stepnem

    This is good advice. Thank you. -- [[mon_key]]

So, to come full circle, Emacs' existing header conventions are a complicated
issue for me and I'm not convinced that the header conventions aren't due for a
correction first. Obv. this would be *a lot* of work. So the cruft persists. It
may be worth asking why it is that you feel compelled to have your header files
conform to Emacs conventions? What are the benefits?

  See above. Even from purely esthetic point of view, I find them nicer than
  yours. -- stepnem
  
    What about the GFDL? Where do external packages put that license? At the top
    of the header?  This is an aesthetic convention that is not well
    reflected/considered by emacs-devels/maintainers because core lisp code is
    distributed and maintained with boilerplate and ``include'' statements.  It
    would be a great exercise to manually examine the headers in the
    Emacs-mirror, ELPA, EmacsWiki to see how third-party authors accomodate
    copyright concerns in file headers. My impression is they simply do not
    mirror those of the core Emacs lisp packages.  -- [[mon_key]]

The only rationale that I can find is to consistently comport with third party
packaging tools.  To the extent that none of these are yet blessed why should
they adhere to the existing conventions either? AFAIK they don't now and have
parsing routines for extracting wayward headers already. IMHO This is one of
these areas where Emacs is broken not the inverse...

Of course, as soon as I'm asked to contribute a package to Emacs proper I'll
gladly get right and my `issues' with the current header conventions will most
likely disappear. ;) -- [[mon_key]]

      Replied by mail (1st March 2010). This is a mess. --stepnem
</pre>

 =]

/s_P\

----
CategoryHomepage
