This page is about conditional control of program flow (evaluation). It contains the following sections:

* '''When to Use Which Conditional Control Structure?''' -- [[#WhichConditional]]
* '''Cond''' -- see [[#Cond]]
* '''If-Then-Else''' -- see [[#IfThenElse]]
* '''When, Unless''' -- see [[#WhenUnless]]
* '''And, Or''' -- see [[#AndOr]]
* '''Case''' -- see [[#Case]]

In Emacs Lisp, all control structures not only control program flow; they also return a value. Sometimes you are interested in this value; sometimes you are not interested in it.

All conditional control structures except `case' include tests for boolean "truth value". In Emacs Lisp, this means testing for `nil'-ness. If an expression evaluates to `nil', then the test is said to fail (the truth value is false); if the expression evaluates to anything else but `nil', then the test is said to succeed (the truth value is true).

For more information on the conditional control structures, consult Info (EmacsLispReference), node Conditionals, or use `C-h f cond', `C-h if' etc.

[:WhichConditional]
= When to Use Which Conditional Control Structure? =

In general, the answer is that you can do anything you want with any control structure. Which you use is a question of style and succinctness. In general, the following heuristics provide a guide:

* Use `and' or `or' if:

** Tests can be ''accumulated sequentially'', stopping with the first that succeeds (`or') or fails (`and').
** A logical ''combination of the test values should be returned'' as the value of the conditional expression. Using `and' or `or' suggests to readers that the return value is important to the surrounding code.

* Use `cond' or `if' if the ''value'' of the conditional expression is important.

* Use `when' or `unless' if the value of the conditional expression is ''not'' important, that is, if you are executing the expression only for its ''side effects''.

: '''Note:''' This is a stylistic concern -- use `when' or `unless' to indicate to readers of the code that the return value is unimportant, that the code is only intended to perform side effects. This communication can help modifiers or reusers of your code.

* Use `cond' if several alternative tests are to be used. Use `if' if one branch of the test will have a single, simple expression to evaluate -- place that branch first. Use `cond', `when' or `unless' if multiple expressions are to be evaluated for a given test.

* Use `case' if the same value is to be compared to several other values. If you find yourself writing this, then consider using `case' instead (but be aware that `case' uses `eql', not `eq' for comparsion):

     (let ((x (y)))
       (cond ((eq x 'lazy) (do-this))
             ((eq x 'spoiled) (do-that))
             ((eq x 'ignorant) (do-this-and-that))
             ((eq x 'dishonest) (do-something-else))
             ((eq x 'incompetent) (do-so-and-so))
             ((eq x 'z) (do-such-and-such))
             (t (must-be-another-x))))

[:Cond]
= Cond =

`cond' is a general conditional construct. With it, you can achieve the functionality of any of the other conditional constructs. These are the things to note about `cond':

* You can use any number of conditional tests.
* Each test can be associated with any number (including zero) of expressions to be evaluated if the test is true.
* The tests are tried in order. The expressions associated with the first succeeding test are executed; no subsequent tests are evaluated.
* The value returned by `cond' is:
** The value of the last expression associated with the successful test.
** The value of the successful test itself, if the test has no associated expressions.
** `nil', if no test is successful.
* You can have an "otherwise", or default, clause that executes if all other tests fail, by using `t' as the last test -- this test always succeeds.


[:IfThenElse]
= If-Then-Else =

`if' is as general as `cond': any other conditional control structure can be expressed in terms of `if', though the result may not always be succinct.

Pretty much any usable programming language out there has something along the lines of the If-Then-Else statement.  Emacs Lisp is no exception:

 (if TEST EVAL-IF-T &rest EVAL-IF-NIL...)

So, you can create a simple conditional like this:

 (if (>= emacs-major-version 21)                        ; this is the test, the "if"
     (message "You are running Emacs 21!  Lucky you.") ; This is the "then"
   (ding)                                              ; From here on is the "else"
   (message "Time to upgrade, don't you think?"))

Notice that if the test is true (and you don't have to use a function there, like I did; a variable, or anything that returns nil if false should work), you get one line to run; if the test is false, then you get the rest of the statements to respond to the false result.  That is called an implicit progn in Emacs jargon, because a <code>progn</code> is a single statement that evals multiple statements inside it.

If you want to run multiple statements if the result is true, then you can do something like this:

 (if (>= emacs-major-version 21)
     (progn
         (ding)
         (message "You are running Emacs 21!  Lucky you."))
   (ding)
   (message "Time to upgrade, don't you think?"))

As you can see, the <code>progn</code> allows us to do for the true result, what we can already do for the false result.  But you can make your code more readable, and you can make it more efficient.  (Sometimes you can even do both.  But not often in my experience.)

[:WhenUnless]
= When, Unless =

There are two new if-like things in Emacs 20 and later, which have implicit progns and help readability:

 (when TEST &rest EVAL-IF-T...)

 (unless TEST &rest EVAL-IF-NIL...)

<code>when</code> tests to see if the test is true, and then runs everything that comes after it if so.  As you may have guessed, <code>unless</code> does the opposite.

 ; Load my abbreviations and use them in all text modes
 (unless (featurep 'xemacs)
   (add-hook 'text-mode-hook (lambda () (abbrev-mode 1)))
   (read-abbrev-file (expand-file-name "~/.abbrev_defs")))

The above is an example of this sort of construct.  I test to see if there is a feature called 'xemacs (which is not the best way of testing for features in general, but oh well, this is an example).  If I am running XEmacs, I don't want to use abbrev mode.  So I tell it to do all of the following ''unless'' I am running XEmacs.  If I had done this with an <code>if</code> statement, I would have had to use a progn, but here the progn is implicit.

For more about implicit progns, have a look at http://www.gnu.org/software/emacs/elisp-manual/html_node/elisp_125.html#SEC125

[:AndOr]
= And, Or =

If you need to test for several things "serially," that is, test for this, then do this, and if that works, then do this, and so on, then you might want to consider using <code>and</code>.  It is a boolean function, sure, but it and <code>or</code> can manage certain orders of tasks on their own.

Consider this function from my [http://www.livingtorah.org/~csebold/emacs/dot.emacs .emacs] to hyphenate previous words:

 (defun crs-hyphenate-last-two-words ()
  "Take the last two words you typed and replace the space between them with a
 hyphen."
  (interactive)
  (save-excursion
    (and (re-search-backward " " nil t)
         (re-search-backward "[^ \n]" nil t)
         (re-search-forward "[ \n]+" nil t)
         (replace-match "-"))))

We start by declaring the function interactive (so I can bind it to a key and use it anytime, and it will show up when doing <code>C-h a</code> for apropos-command).  Then we wrap the rest of the code in <code>save-excursion</code>, which will restore the location of point and other things when we are done.

Following that is a long <code>and</code> statement.  I want to test for each of these things, and I want point to move along with the tests.  If any of these fail, I want the whole operation to stop.  <code>and</code> and <code>or</code> only perform the tests they need to perform; that is, since <code>and</code> is testing to see if everything in the list is true, it will stop if any of these operations return a <code>nil</code>.  <code>or</code> is the same way; as soon as something returns a value other than nil, it will stop the tests.

In the example, then, it first tests to see if there is a space before the current location of point.  If that passes, then on to step two; if not, then the whole and statement, and the function in our example, is done.  Next it tests (from where the last search left off, write after the first space it found) for the next character that is neither a space nor a newline.  Finding that, it now looks forward again, to capture all of the spaces and/or newlines that follow, and finding those (as it almost has to based on the last searches) it replaces the match with a hyphen.

We did all of that without using an <code>if</code> statement!  And it is clear to the reader who understands, that each of these has to be performed successfully in series in order to allow the hyphenation to occur.

[:Case]
= Case =

`case' is a bit like `cond', in that it can involve multiple tests. What really distinguishes `case' is that a single test expression is evaluated ''once'', and the result is ''compared to other values''. Comparison is done using Common-Lisp function `eql'. 

The first comparison that succeeds provokes execution of its associated expressions, much as for `cond'. A `case' expression can include a final default clause by using a comparison value of `t' or `otherwise'. Comparison values can be ''grouped'', so that several values will lead to the same consequence code being executed. 

`case' is part of the Common Lisp package. To use it, you must `<code>(require 'cl)</code>'.


----
CategoryCode
