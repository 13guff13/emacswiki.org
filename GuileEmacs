For the former contents of this page which were for a large part concerned with the history of all efforts to integrate Guile and Emacs, see GuileEmacsHistory.

== Overview ==

Guile-based Emacs (possibly called "guilemacs" or Guile-Emacs) is a branch of GNU Emacs that replaces Emacs's own EmacsLisp engine with that of [[Guile]].

The first immediate advantage is that Elisp will execute faster, because Guile uses a compiler tower with many optimization passes and ultimately compiles to Guile VM bytecode, which is more efficient than current Elisp bytecode. In the future, Guile is likely to implement some forms of native JIT as well as AOT compilation as well.

A second advantage is that it will be easier to implement some additional language features for Elisp which the Guile compiler tower and VM are capable of, like a full numeric tower (infinite-sized integers, exact rational numbers, imaginary numbers, etc.), record types (like an improved defstruct), CLOS-like OOP, an FFI, composable continuations, a module system, hygienic macros, multiple-value returns, and threads.

A third advantage is all Guile APIs/libraries becoming available to Elisp code, no matter what language they're implemented in, because different languages on the Guile VM can inter-operate quite well, especially if they're both a Lisp. C-implemented functions ("subrs" in Elisp terminology), Elisp functions, Scheme procedures, etc. all compile to the same "procedure" data type, which may appear in Elisp symbols' function-slots, be bound to Scheme variables, and are otherwise first-class objects in both environments which can be funcalled or applied explicitly or by the language's normal syntactic way of calling functions. Similarly, other data types are unified between the languages; Elisp integers and exact Scheme integers, inexact Scheme numbers and Elisp floats, Elisp cons cells and Scheme pairs, symbols, etc. are the same data type across the languages. (Strings are an exception though; see below.) Therefore one can generally use a library written in another language as if it were written in the same language.

Lastly, it will become possible to write Emacs extensions in Scheme instead of Elisp, where it's possible to load the Elisp function and variable namespaces as modules (say with a prefix for each so common names like `car' aren't overwritten).


== Current State ==

The latest publicly available state of GuileEmacs can be found at [http://git.hcoop.net/?p=bpt/emacs.git BT Templeton's Emacs repository] and in [http://git.hcoop.net/?p=bpt/guile.git their Guile repository]. The "wip" branches of both represent the latest state of GuileEmacs and _both_ are necessary to test it. (Build the wip branch of the Guile repo first, then build the wip branch of the Emacs repo with that.)

As of the end of GoogleSummerOfCode 2014, the Elisp engine of Emacs is fully replaced with that of libguile, and most things Just Workâ„¢. Some performance regression of dynamic scoping (lexically scoped code should be fine), and broken corner cases (like crazy Elisp macros that directly output legacy Elisp bytecode) remain. See GuileEmacsTodo.

=== How to build? ===

NOTE: The validity of this section could change at any time when the repos get updates.

As mentioned above, build the wip branch of the above linked Guile repo first, install it such that it will be available during the Emacs build, and then build the wip branch of the above linked Emacs repo.

While building the Emacs wip branch, you might need to run "make -k" several times, and I had to export LD_LIBRARY_PATH=/path/to/libguile during the build and for launching the resulting emacs executable. In my case, /path/to/libguile is <code>~/usr/lib</code> which is where I installed the wip Guile build.

You also need libgc 7.4.2 (latest version) and preferably a recent GCC. Version 4.7 from Debian stable worked for me.

Of course you also need all the usual dependencies of Guile and Emacs. Their normal installation instructions will tell you (see README file and INSTALL file and all).

=== Dynamic scoping ===

Elisp defvars are dynamically scoped, as well as let-bound variables when lexical scope isn't enabled for an Elisp file. These use the same machinery as parameter objects in Scheme. Currently these are not as efficient as they should be, and the presence of buffer-local variables and other weirdities of Elisp binding mechanisms cause additional headaches to libguile in implementing Elisp, which so far leads to a very big performance regression. This will hopefully be addressed shortly.

=== So can I script Emacs in Scheme already?! ===

For the Scheme fans who dislike Elisp:

http://i.imgur.com/5DYQbhu.png

(Note: I do NOT endorse using Apple products. The above screenshot being from Mac OS X is an unfortunate coincidence.)


== Long-term issues ==

There seem no long-term issues for pure Elisp users, but the following challenges will face those who want to mix Elisp with Scheme:

=== Strings ===

Elisp strings are encoded in an extended UTF-8 format, whereas Guile just uses libunistring. For this reason Elisp strings will for starters be a separate data type from other Guile strings (say coming from Scheme code). This poses no problems to pure Elisp code, but limits one's ability to seamlessly use Scheme libraries from Elisp, and to write Emacs extensions in Scheme, because one needs to explicitly convert back and forth between Elisp and Scheme strings.


=== Nil, false, and the empty list ===

Scheme uses separate objects for the false boolean and the empty list object (null); Elisp uses nil for both. This poses problems in the interoperation of the languages. Guile approaches the issue by having all three objects: false, null, and nil. In Elisp, all three are interchangeable. In Scheme, nil can take the role of both false and null. Despite all that, none of the objects are `equalp' (Elisp) or <code>equal?</code> (Scheme) to each other (let alone `eql'/<code>eqv?</code> or `eq'/<code>eq?</code>).

The nil object can be represented as <code>#nil</code> in Scheme. The false and null objects have no Elisp representation. (Not yet anyway, or at least not properly. Actually, printing false yields <code>#f</code> and printing null yields <code>()</code>, but the former is invalid read syntax and the latter would be recognized as `nil' if read back in. So these should probably be changed.)

To speak in examples: in Scheme, <code>(if #nil 0 1)</code> yields 1, <code>(and (not #nil) (null? #nil))</code> yields true, and <code>(cons 'foo #nil)</code> yields <code>(foo)</code>. In Elisp, assuming false is bound to `false' and null to `null', <code>(if (or false null) 0 1)</code> yields 1, <code>(and (not null) (null false))</code> yields true, and <code>(cons 'foo false)</code> yields <code>(foo)</code>.

As an additional weirdity, the nil and true objects are symbols in Elisp, since after all they're `nil' and `t'. They are not symbols in Scheme though, despite being the same objects. (The Elisp `symbolp' function and Scheme <code>symbol?</code> procedure simply disagree here, among some others which deal with symbols.)

All in all, things should simply work fine as long as the user writes well-abstracted code that uses `if', `not', <code>null?</code>, etc. instead of comparing equality to literal objects. Time will tell whether the internal mess with lead to problems in practice. (At least checking the truthiness of nil and false is still both very cheap thanks to some low-level magic in libguile, so code isn't slowed down by the presence of the extra nil object that needs to act as a false value.)

A notorious algorithm that won't work without modification is one to find the common tail of two lists that share structure. This algorithm cuts two lists to the same length, then walks them in parallel and does an `eq' check on every pair of nodes. Normally this will end at least when the `nil' at the end of both lists is reached (meaning their only common tail is the empty list), but in mixed Scheme/Elisp code one has to separately check for the <code>(and (null list1-tail) (null list2-tail))</code> case at every node (actually testing one of the two is enough because they have the same length), or else one has to canonicalize the lists's terminating value in advance.

<b>Long story short:</b> If you use Scheme libraries from Elisp or vice versa, you have to make sure to always use `not' and `null' instead of comparing equality to `nil' (via `eq'). And you can't assume that two lists both end in the same object as in `eq', which is otherwise guaranteed in Lisps.


=== Macros ===

While procedures are shared between the languages, macros are more difficult. Elisp macros are just procedures of course so they could in principle work as unhygienic Scheme macros, and Elisp code goes through the same intermediate language as Scheme so perhaps hygienic Scheme macros could work on Elisp.

The former would probably not work sensibly though, since Elisp function and variable names appearing in the macro output would be inserted into Scheme code where they're undefined.

The latter might just work. Scheme's hygienic macros don't output Scheme code (raw sexprs); they output code in an intermediate language (IL) that can make direct references to bindings in any modules, as well as represent all code concepts that libguile supports in the lower levels. Scheme and Elisp are already both translated to this IL before further compilation or interpretation, so using hygienic macros defined in Scheme on Elisp code would not have any issues; it would simply separately compile (to IL) the Scheme body of the macro template and the Elisp code snippet inputs to the macro, and merge these IL snippets which both reference the correct Scheme and Elisp variable and function bindings. Even identifier inputs to the macro which it binds with `let', like in <code>(syntax-rules () ((with-foo foo body ...) (let ((foo whatever)) body ...)))</code>, should conceptually work (*lexically* bind `foo' for the Elisp code in `body'), except that if the macro means to bind `foo' to a procedure then the Elisp code in `body' will need to use `funcall' or `apply' with the variable `foo' since Elisp has a separate function namespace.

It should also be possible to implement a hygienic macro definition form for Elisp, though `defmacro' itself can probably not be made hygienic so using all the currently existing Elisp macros from Scheme remains problematic. They will probably need to be slowly reimplemented as hygienic macros defined in Elisp or Scheme.


== See Also ==
GuileEmacsTodo
GuileEmacsHistory

----
CategoryGuileEmacs CategoryExtensionLanguage EmacsImplementations
