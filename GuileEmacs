For the former contents of this page which were for a large part concerned with the history of all efforts to integrate Guile and Emacs, see GuileEmacsHistory.

== Overview ==

Guile-based Emacs (alternatively called "guilemacs" or Guile-Emacs) is a branch of GNU Emacs that replaces the Elisp engine with libguile ([[Guile]]), which can compile and interpret EmacsLisp alongside Scheme, with more or less seamless interoperation between the languages.

Elisp functions and Scheme procedures both compile to libguile procedure objects, which may appear in Elisp symbols' function-slots, may be bound to Scheme variables, and are otherwise first-class objects in both environments which can be funcalled or applied explicitly or by the language's normal syntactic way of calling functions/procedures. Similarly, other data types are unified between the languages; Elisp integers and exact Scheme integers, inexact Scheme numbers and Elisp floats, strings and cons cells and symbols from both languages, etc. Elisp-specific data types like buffers and windows are integrated with libguile too so Scheme can use them, and Elisp functions written in C ("subrs") also become libguile procedures.

This way GNU Emacs as we know it continues working with all its Elisp, but Elisp code can call any procedures from the Guile API or Scheme libraries, and with some work it becomes feasible to extend Emacs in Scheme natively, offering a direct alternative to Elisp. Many features of Guile like its FFI, composable continuations, or possibly JIT and AOT native compilation in the future become automatically available to Elisp.


== Current State ==

The latest publicly available state of GuileEmacs can be found at [http://git.hcoop.net/?p=bpt/emacs.git BT Templeton's Emacs repository] and in [http://git.hcoop.net/?p=bpt/guile.git their Guile repository]. The "wip" branches of both represent the latest state of GuileEmacs and _both_ are necessary to test it. (Build the wip branch of the Guile repo first, then build the wip branch of the Emacs repo with that.)

As of the end of GoogleSummerOfCode 2014, the Elisp engine of Emacs is fully replaced with that of libguile, and most things Just Workâ„¢. Some performance regression of dynamic scoping (lexically scoped code should be fine), and broken corner cases (like crazy Elisp macros that directly output legacy Elisp bytecode) remain. See GuileEmacsTodo.


== Nil, false, and the empty list ==

Scheme uses `#false' and `()' for the false boolean and empty/end-of list, respectively. Elisp uses `nil' for both. This poses a problem in the interoperation of the languages. Guile approaches this issue by supporting a nil object that is `nil' in Elisp and `#nil' in Scheme (would not normally be generated by Scheme code but can come from Elisp calls), in addition to the usual false and null objects represented as `#false' and `()' in Scheme.

In Scheme, nil is false (as per `if') and responds to `null?' (returns true), being able to terminate lists as an alternative to `()'. It is not `eq?' to either of `#false' or `()', but things should work fine as long as the user writes well-abstracted code that uses `if', `not', `null?', etc. instead of comparing equality to a literal.

In Elisp, the false object that comes from Scheme returns true when passed to `not' or `null', but may not terminate lists. The null object *also* returns true for `not' and `null' (note that they're actually aliases in Elisp anyway) *and* may terminate lists.

All that aside, `nil' and `t' are also symbols in Elisp, aside from evaluating to the nil and true libguile objects when due.

Time will tell whether this internal mess with lead to problems in practice. At least checking the truthiness or nil and false is still both very cheap so compiled code isn't slowed down by the presence of the nil object in libguile.


== Dynamic scoping ==

Elisp defvars are dynamically scoped, as well as let-bound variables when lexical scope isn't enabled for an Elisp file. These use the same machinery as parameter objects in Scheme. Currently these are not as efficient as they should be, and the presence of buffer-local variables and other weirdities of Elisp binding mechanisms cause additional headaches to libguile in implementing Elisp, which so far leads to a very big performance regression. This will hopefully be addressed shortly.


== Macros ==

While procedures are shared between the languages, macros are more difficult. Elisp macros are also just procedures of course so they could work as unhygienic Scheme macros, and Elisp code goes through the same intermediate language as Scheme so perhaps Scheme macros will work on Elisp too, but probably neither will happen in practice, macros written in one language staying in that language. This means that macro portions of Elisp and Scheme libraries might need to be written in both languages when one wishes the library to be available in both languages. Remember that macros should be kept to the minimum possible in Lisp code though, since procedures/functions have other advantages over them. (Only write a macro when a function cannot possibly do the same thing.)


== See Also ==
GuileEmacsTodo
GuileEmacsHistory

----
CategoryGuileEmacs CategoryExtensionLanguage EmacsImplementations
