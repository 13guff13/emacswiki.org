For the former contents of this page which were for a large part concerned with the history of all efforts to integrate Guile and Emacs, see GuileEmacsHistory.

== Overview ==

Guile-based Emacs (alternatively called "guilemacs" or Guile-Emacs) is a branch of GNU Emacs that replaces the Elisp engine with libguile ([[Guile]]), which can compile and interpret EmacsLisp alongside [[Scheme]], with more or less seamless interoperation between the languages.

Elisp functions and Scheme procedures both compile to libguile procedure objects, which may appear in Elisp symbols' function-slots, may be bound to Scheme variables, and are otherwise first-class objects in both environments which can be funcalled or applied explicitly or by the language's normal syntactic way of calling functions/procedures. Similarly, other data types are unified between the languages; Elisp integers and exact Scheme integers, inexact Scheme numbers and Elisp floats, strings and cons cells and symbols from both languages, etc. Elisp-specific data types like buffers and windows are integrated with libguile too so Scheme can use them, and Elisp functions written in C ("subrs") also become libguile procedures.

This way GNU Emacs as we know it continues working with all its Elisp, and Elisp code can additionaly call any procedures from the Guile API or Scheme libraries, and with some work it becomes feasible to extend Emacs in Scheme natively, offering a direct alternative to Elisp. Many features of Guile like its FFI, composable continuations, or possibly JIT and AOT native compilation in the future become automatically available to Elisp.


== Current State ==

The latest publicly available state of GuileEmacs can be found at [http://git.hcoop.net/?p=bpt/emacs.git BT Templeton's Emacs repository] and in [http://git.hcoop.net/?p=bpt/guile.git their Guile repository]. The "wip" branches of both represent the latest state of GuileEmacs and _both_ are necessary to test it. (Build the wip branch of the Guile repo first, then build the wip branch of the Emacs repo with that.)

As of the end of GoogleSummerOfCode 2014, the Elisp engine of Emacs is fully replaced with that of libguile, and most things Just Workâ„¢. Some performance regression of dynamic scoping (lexically scoped code should be fine), and broken corner cases (like crazy Elisp macros that directly output legacy Elisp bytecode) remain. See GuileEmacsTodo.

=== How to build? ===

NOTE: The validity of this section could change at any time when the repos get updates.

As mentioned above, build the wip branch of the above linked Guile repo first, install it such that it will be available during the Emacs build, and then build the wip branch of the above linked Emacs repo.

While building the Emacs wip branch, you might need to run "make -k" several times, and I had to export LD_LIBRARY_PATH=/path/to/libguile during the build and for launching the resulting emacs executable. In my case, /path/to/libguile is <code>~/usr/lib</code> which is where I installed the wip Guile build.

You also need libgc 7.4.2 (latest version) and preferably a recent GCC. Version 4.7 from Debian stable worked for me.

Of course you also need all the usual dependencies of Guile and Emacs. Their normal installation instructions will tell you (see README file and INSTALL file and all).

=== Dynamic scoping ===

Elisp defvars are dynamically scoped, as well as let-bound variables when lexical scope isn't enabled for an Elisp file. These use the same machinery as parameter objects in Scheme. Currently these are not as efficient as they should be, and the presence of buffer-local variables and other weirdities of Elisp binding mechanisms cause additional headaches to libguile in implementing Elisp, which so far leads to a very big performance regression. This will hopefully be addressed shortly.

=== So can I script Emacs in Scheme already?! ===

http://i.imgur.com/5DYQbhu.png

(Note: I do NOT endorse using Apple products. The above screenshot being from Mac OS X is an unfortunate coincidence.)


== Nil, false, and the empty list ==

Scheme uses separate objects for the false boolean and the empty list object (null); Elisp uses nil for both. This poses problems in the interoperation of the languages. Guile approaches the issue by having all three objects: false, null, and nil. In Elisp, all three are interchangeable. In Scheme, nil can take the role of both false and null. Despite all that, none of the objects are `equalp' (Elisp) or <code>equal?</code> (Scheme) to each other (let alone `eql'/<code>eqv?</code> or `eq'/<code>eq?</code>).

The nil object can be represented as <code>#nil</code> in Scheme. The false and null objects have no Elisp representation. (Not yet anyway, or at least not properly. Actually, printing false yields <code>#f</code> and printing null yields <code>()</code>, but the former is invalid read syntax and the latter would be recognized as `nil' if read back in. So these should probably be changed.)

To speak in examples: in Scheme, <code>(if #nil 0 1)</code> yields 1, <code>(and (not #nil) (null? #nil))</code> yields true, and <code>(cons 'foo #nil)</code> yields <code>(foo)</code>. In Elisp, assuming false is bound to `false' and null to `null', <code>(if (or false null) 0 1)</code> yields 1, <code>(and (not null) (null false))</code> yields true, and <code>(cons 'foo false)</code> yields <code>(foo)</code>.

As an additional weirdity, the nil and true objects are symbols in Elisp, since after all they're `nil' and `t'. They are not symbols in Scheme though, despite being the same objects. (The Elisp `symbolp' function and Scheme <code>symbol?</code> procedure simply disagree here, among some others which deal with symbols.)

All in all, things should simply work fine as long as the user writes well-abstracted code that uses `if', `not', <code>null?</code>, etc. instead of comparing equality to literal objects. Time will tell whether the internal mess with lead to problems in practice. (At least checking the truthiness of nil and false is still both very cheap thanks to some low-level magic in libguile, so code isn't slowed down by the presence of the extra nil object that needs to act as a false value.)


== Macros ==

While procedures are shared between the languages, macros are more difficult. Elisp macros are just procedures of course so they could in principle work as unhygienic Scheme macros, and Elisp code goes through the same intermediate language as Scheme so perhaps hygienic Scheme macros could work on Elisp.

The former would probably not work sensibly though, since Elisp function and variable names appearing in the macro output would be inserted into Scheme code where they're undefined.

The latter might just work. Scheme's hygienic macros don't output Scheme code (raw sexprs); they output code in an intermediate language (IL) that can make direct references to bindings in any modules, as well as represent all code concepts that libguile supports in the lower levels. Scheme and Elisp are already both translated to this IL before further compilation or interpretation, so using hygienic macros defined in Scheme on Elisp code would not have any issues; it would simply separately compile (to IL) the Scheme body of the macro template and the Elisp code snippet inputs to the macro, and merge these IL snippets which both reference the correct Scheme and Elisp variable and function bindings. Even identifier inputs to the macro which it binds with `let', like in <code>(syntax-rules () ((with-foo foo body ...) (let ((foo whatever)) body ...)))</code>, should conceptually work (*lexically* bind `foo' for the Elisp code in `body'), except that if the macro means to bind `foo' to a procedure then the Elisp code in `body' will need to use `funcall' or `apply' with the variable `foo' since Elisp has a separate function namespace.

It should also be possible to implement a hygienic macro definition form for Elisp, though `defmacro' itself can probably not be made hygienic so using all the currently existing Elisp macros from Scheme remains problematic. They will probably need to be slowly reimplemented as hygienic macros defined in Elisp or Scheme.


== See Also ==
GuileEmacsTodo
GuileEmacsHistory

----
CategoryGuileEmacs CategoryExtensionLanguage EmacsImplementations
