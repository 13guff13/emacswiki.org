This page is about library '''%%NaKeD%%''', <tt>[[naked.el]]</tt>, which provides for <u>'''''n'''''</u>o-<u>'''''a'''''</u>ngles <u>'''''k'''''e</u>y <u>'''''d'''''</u>escriptions.  It lets you use [[key sequence|key-sequence]] descriptions that do not bother with '''angle brackets''': '''`##<##'''' and '''`##>##''''.

Prior to Emacs 21, vanilla GnuEmacs did not bother with angle brackets either, but someone around the turn of the century had the bright idea that Emacs could not do without them.  So instead of the `delete' key we now have the `##<delete>##' key.  And instead of `C-x M-delete' we now have 
`##C-x M-<delete>##'.  ''On n'arrete pas le progres !''

If you think that's silly, well, now there are two of us...

All I can think of is that some misguided soul forgot that we already use spaces to separate keys in a key-sequence description (we use `SPC' to indicate the ##SPACE## key).  So we don't need no stinkin' brackets to separate keys.  Perhaps someone thought we could not distinguish `C-d elete' from `C-delete' (the former being the two-key sequence  `C-d' followed by the yet-to-be-defined function key `elete').

Well, we can distinguish them, and no, we do not need angle brackets, because we already have spaces to separate keys in a sequence.

To be fair, it is true that sometimes people have taken the shortcut when writing about user input of writing, e.g., `M-x forward-char RET' instead of writing `M-x f o r w a r d - c h a r'.  And if you write `forward' that way to stand for an input sequence of seven chars, then you cannot also expect `forward' to stand for a function key named "forward", can you?

Well, yes you can, if the context makes things clear enough.  And I for one (maybe the only one), find `##C-M-<insert>##' butt-ugly (likewise `##<C-M-insert>##') -- and, more importantly, insulting to [[WikiPedia:Occam's_razor|Occam]].

So go ahead and ''go '''NaKeD''''' -- shed your angles.

Here's what you need.  It won't completely purge Emacs from insulting you with the occasional pair of angle brackets, but it at least lets you DTRT in code you write:

* Use function `naked-key-description' instead of `key-description'.  The former outputs naked key descriptions: no angle brackets around function keys.  E.g., if ##KEY## is the sequence of events produced by holding the ##Shift## key while hitting the ##Insert## key, then ##(naked-key-description KEY)## returns ##"S-insert"## (and not ##"S-<insert>"##).  (Internally, this sequence of events is the vector ##[S-insert]##.)

* Use [[macro]] `naked' instead of macro `kbd'.  The former expects its argument key-sequence description to use naked keys, not clothed in angle brackets.  E.g., ##(naked "C-M-delete")## has the same effect as ##(kbd "C-M-<delete>")##.

* Use [[command]] `naked-read-kbd-macro' instead of `read-kbd-macro'.

* Use function `naked-edmacro-parse-keys' instead of `edmacro-parse-keys' (if you happen to use that lower-level function).

But you can also have it both ways if or when you might need to: All of these accept an optional argument ##ANGLES## which, if non-`nil', returns the behavior to the brain-dead vanilla one, expecting function keys to be fully clothed in angle brackets.  Example:
##(naked "C-M-<delete>" t)##

''Enjoy!''

[new]

`naked-edmacro-parse-keys' doesn't do the right thing with strings like ##M-TAB##:

    (naked "M-TAB")=> [M-TAB]
    (kbd "M-TAB") => [134217737]

As a result `define-key' (at least in 24.2.1) complains

    To bind the key M-TAB, use "\M-\t\", not [M-TAB]

What I am trying to do is this:

    (defun naked-define-key (keymap key def)
      "In KEYMAP, define key sequence KEY as DEF.
    Like `define-key' but if KEY is a string it has to be in the
    `naked' format without angle brackets."
      (define-key keymap
        (if (stringp key)
            (naked-read-kbd-macro key)
          key)
        def))

Thanks for this library, and for looking into this issue. -- JonasBernoulli

[new]
Ahhh... had a closer look at `naked.el' turns out you already took care of this but forgot to add TAB to ##"\\<\\(NUL\\|RET\\|LFD\\|ESC\\|SPC\\|DEL\\)$"##

Anyways what do you think about adding the above function (or similar) to `naked.el'.  Maybe even something like this too:

    (defun naked-remove-key (keymap key)
      "In KEYMAP, remove key sequence KEY.
    If KEY is a string it has to be in the `naked' format without
    angle brackets.

    This removes the key sequence KEY from KEYMAP.  This differs from
    using `undefined' or nil as definition.  `undefined' is a command
    like any other and calling `define-key' with nil as definition
    merely \"undefines\" the key by setting it to nil (but without
    actually removing the event from the keymap)."
      (when (stringp key)
        (setq key (naked-read-kbd-macro key t)))
      (define-key keymap key nil)
      ;; FIXME
      (if (> (length key) 1)
          (delete (last (setq key (append key nil)))
                  (lookup-key keymap (apply 'vector (butlast key))))
        (delete (cons key nil) keymap)))

    (defmacro naked-define-keys (mapvar feature &rest plist)
      "Define all keys in PLIST in the keymap stored in MAPVAR.
    If a key in PLIST is a string it has to be in the `naked' format
    without angle brackets.  `:remove' as a key definition means that
    the existing definition (if any) should be remove from the keymap
    using `naked-remove-key'."
      (declare (indent 2))
      (if feature
          `(eval-after-load ',feature
             (naked-define-keys-1 ',mapvar ',plist))
        `(naked-define-keys-1 ',mapvar ',plist)))

    (defun naked-define-keys-1 (keymap plist)
      (when (symbolp keymap)
        (setq keymap (symbol-value keymap)))
      (unless (keymapp keymap)
        (error "Not a keymap"))
      (while plist
        (unless (cdr plist)
            (error "Odd number of elements in PLIST"))
        (let ((key (pop plist))
              (def (pop plist)))
          (if (eq def :remove)
              (naked-remove-key keymap key)
            (naked-define-key keymap key def)))))

-- JonasBernoulli

----
CategoryCode
