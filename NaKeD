This page is about library '''%%NaKeD%%''', <tt>[[naked.el]]</tt>, which provides for <u>'''''n'''''</u>o-<u>'''''a'''''</u>ngles <u>'''''k'''''e</u>y <u>'''''d'''''</u>escriptions.  It lets you use [[key sequence|key-sequence]] descriptions that do not bother with '''angle brackets''': '''`##<##'''' and '''`##>##''''.

Prior to Emacs 21, vanilla GnuEmacs did not bother with angle brackets either, but someone around the turn of the century had the bright idea that Emacs could not do without them.  So instead of the `delete' key we now have the `##<delete>##' key.  And instead of `C-x M-delete' we now have 
`##C-x M-<delete>##'.  ''On n'arrete pas le progres !''

If you think that's silly, well, now there are two of us...

All I can think of is that some misguided soul forgot that we already use spaces to separate keys in a key-sequence description (we use `SPC' to indicate the ##SPACE## key).  So we don't need no stinkin' brackets to separate keys.  Perhaps someone thought we could not distinguish `C-d elete' from `C-delete' (the former being the two-key sequence  `C-d' followed by the yet-to-be-defined function key `elete').

Well, we can distinguish them, and no, we do not need angle brackets, because we already have spaces to separate keys in a sequence.

To be fair, it is true that sometimes people have taken the shortcut when writing about user input of writing, e.g., `M-x forward-char RET' instead of writing `M-x f o r w a r d - c h a r'.  And if you write `forward' that way to stand for an input sequence of seven chars, then you cannot also expect `forward' to stand for a function key named "forward", can you?

Well, yes you can, if the context makes things clear enough.  And I for one (maybe the only one), find `##C-M-<insert>##' butt-ugly (likewise `##<C-M-insert>##') -- and, more importantly, insulting to [[WikiPedia:Occam's_razor|Occam]].

So go ahead and ''go '''NaKeD''''' -- shed your angles.

Here's what you need.  It won't completely purge Emacs from insulting you with the occasional pair of angle brackets, but it at least lets you DTRT in code you write:

* Use function `naked-key-description' instead of `key-description'.  The former outputs naked key descriptions: no angle brackets around function keys.  E.g., if ##KEY## is the sequence of events produced by holding the ##Shift## key while hitting the ##Insert## key, then ##(naked-key-description KEY)## returns ##"S-insert"## (and not ##"S-<insert>"##).  (Internally, this sequence of events is the vector ##[S-insert]##.)

* Use [[macro]] `naked' instead of macro `kbd'.  The former expects its argument key-sequence description to use naked keys, not clothed in angle brackets.  E.g., ##(naked "C-M-delete")## has the same effect as ##(kbd "C-M-<delete>")##.

* Use [[command]] `naked-read-kbd-macro' instead of `read-kbd-macro'.

* Use function `naked-edmacro-parse-keys' instead of `edmacro-parse-keys' (if you happen to use that lower-level function).

But you can also have it both ways if or when you might need to: All of these accept an optional argument ##ANGLES## which, if non-`nil', returns the behavior to the brain-dead vanilla one, expecting function keys to be fully clothed in angle brackets.  Example:
##(naked "C-M-<delete>" t)##

''Enjoy!''

[new]

`naked-edmacro-parse-keys' doesn't do the right thing with strings like ##M-TAB##:

    (naked "M-TAB")=> [M-TAB]
    (kbd "M-TAB") => [134217737]

As a result `define-key' (at least in 24.2.1) complains

    To bind the key M-TAB, use "\M-\t\", not [M-TAB]

What I am trying to do is this:

    (defun naked-define-key (keymap key def)
      "In KEYMAP, define key sequence KEY as DEF.
    Like `define-key' but if KEY is a string it has to be in the
    `naked' format without angle brackets."
      (define-key keymap
        (if (stringp key)
            (naked-read-kbd-macro key)
          key)
        def))

Thanks for this library, and for looking into this issue. -- JonasBernoulli

[new]
Ahhh... had a closer look at `naked.el' turns out you already took care of this but forgot to add TAB to ##"\\<\\(NUL\\|RET\\|LFD\\|ESC\\|SPC\\|DEL\\)$"##

Anyways what do you think about adding the above function (or similar) to `naked.el'.  Maybe even something like this too:

    (defun naked-remove-key (keymap key)
      "In KEYMAP, remove key sequence KEY.
    If KEY is a string it has to be in the `naked' format without
    angle brackets.

    This removes the key sequence KEY from KEYMAP.  This differs from
    using `undefined' or nil as definition.  `undefined' is a command
    like any other and calling `define-key' with nil as definition
    merely \"undefines\" the key by setting it to nil (but without
    actually removing the event from the keymap)."
      (when (stringp key)
        (setq key (naked-read-kbd-macro key t)))
      (define-key keymap key nil)
      ;; FIXME
      (if (> (length key) 1)
          (delete (last (setq key (append key nil)))
                  (lookup-key keymap (apply 'vector (butlast key))))
        (delete (cons key nil) keymap)))

    (defmacro naked-define-keys (mapvar feature &rest plist)
      "Define all keys in PLIST in the keymap stored in MAPVAR.
    If a key in PLIST is a string it has to be in the `naked' format
    without angle brackets.  `:remove' as a key definition means that
    the existing definition (if any) should be remove from the keymap
    using `naked-remove-key'."
      (declare (indent 2))
      (if feature
          `(eval-after-load ',feature
             (naked-define-keys-1 ',mapvar ',plist))
        `(naked-define-keys-1 ',mapvar ',plist)))

    (defun naked-define-keys-1 (keymap plist)
      (when (symbolp keymap)
        (setq keymap (symbol-value keymap)))
      (unless (keymapp keymap)
        (error "Not a keymap"))
      (while plist
        (unless (cdr plist)
            (error "Odd number of elements in PLIST"))
        (let ((key (pop plist))
              (def (pop plist)))
          (if (eq def :remove)
              (naked-remove-key keymap key)
            (naked-define-key keymap key def)))))

[new]

Do you have a suggestion how `naked-remove-key' could be fixed?  The biggest problem is that it assumes that ##(naked-read-kdb-macro "M-a")## return [27 97] and not [134217825]. Would it be hard to write a function that did return the former, so that I can reliably get the "keymap containg the final binding"? (Then I should also remove keymaps on the way that become empty as binding in their respective containing keymap, but that's an other issue).  -- JonasBernoulli

[new:DrewAdams:2012-09-25 20:56 UTC]
Hi Jonas.  I'm no expert on this stuff.  Function `naked-edmacro-parse-keys' is based on the code for `edmacro-parse-keys', to which it is almost identical.  All I did was try to handle symbols without angle brackets and handle them inside angle brackets optionally (arg ##ANGLES##).

1. Wrt ##M-TAB##, for instance: the test against ##"\\<\\(NUL\\|RET\\|LFD\\|ESC\\|SPC\\|DEL\\)$"## was already in the `edmacro-parse-keys' code.  I would be hesitant to add ##TAB## there without understanding better.  Do you want to try it and test with both `nil' and non-`nil' ##ANGLES## values?

The other question I have in that regard is what happens on different Emacs versions.

I notice BTW that ##(edmacro-parse-keys "<M-RET>")## returns ##[134217741]##, whereas ##(edmacro-parse-keys "<M-ret>")## returns ##[M-ret]##.

So I guess (?) you're talking about ##TAB## as `C-i' and not ##<tab>## --- analogous to ##RET## as `C-m' and not ##<return>##.

I'm not against adding ##TAB## to the list, if you would please take a closer look and verify that it seems to be the right thing to do.  I don't have time to do that now.

2. I took a quick look at your code.  It's not clear to my why those functions would be needed/useful.  Why not just use `naked' in the ##KEY## position for `define-key', as users typically do for `kbd'?

IOW, why is this any different than for `kbd'?  We don't have functions `kbd-define-key', `kbd-remove-key', and `kbd-define-keys'.  And there are lots of other Emacs functions that accept a ##KEY## parameter.  You don't want to duplicate them all, do you? We should be able to just pass a call to macro `naked' as the ##KEY## argument value for any function.

IOW, just what is the problem that you are trying to solve by adding those functions?

I understand the ##TAB## thing, and that sounds like a bug to be fixed in <tt>[[naked.el]]</tt> (and maybe also in ##edmacro.el##?).

I'm in favor of fixing it, if you can check a bit more, to make sure wrt the fix etc.  My hesitancy is because the vanilla Emacs code does not handle ##TAB## here.

But assuming that is a bug, and assuming we fix it, why would you then need `naked-define-key' etc.?

It's perhaps easier to correspond by email.  Feel free to do that, if you like.

Thx -- DrewAdams









----
CategoryCode
